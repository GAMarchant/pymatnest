#!/usr/bin/env python

import sys

print_prefix=""

if len(sys.argv) != 1:
  sys.stderr.write("Usage: %s < input\n" % sys.argv[0])
  sys.stderr.write("input:\n")
  sys.stderr.write("start_file=path_to_file.xyz (mutually exclusive with restart_file, one is required)\n")
  sys.stderr.write("restart_file=path_to_file.xyz (mutually exclusive with start_file, one is required)\n")
  sys.stderr.write("n_walkers=int (MANDATORY)\n")
  sys.stderr.write("n_cull=int (MANDATORY)\n")
  sys.stderr.write("n_extra_walk_per_task=int (0)\n")
  sys.stderr.write("n_iter=int (MANDATORY)\n")
  sys.stderr.write("initial_energy_ceiling=float (MANDATORY)\n")
  sys.stderr.write("out_file_prefix=str (None)\n")
  sys.stderr.write("\n")
  sys.stderr.write("QUIP_pot_args=str (MANDATORY)\n")
  sys.stderr.write("QUIP_pot_params_file=str (MANDATORY)\n")
  sys.stderr.write("\n")
  sys.stderr.write("MC_atom_n_steps_expected=int (0)\n")
  sys.stderr.write("MC_atom_n_steps=int (if not specified, set from expected #)\n")
  sys.stderr.write("MC_atom_step_size=float (0.1)\n")
  sys.stderr.write("MC_atom_step_size_max=float (1.0\n")
  sys.stderr.write("\n")
  sys.stderr.write("MC_adjust_step_interval=int\n")
  sys.stderr.write("\n")
  sys.stderr.write("MD_atom_n_steps_expected=int (0)\n")
  sys.stderr.write("MD_atom_n_steps=int (if not specified, set from expected #)\n")
  sys.stderr.write("MD_atom_timestep=float (1.0)\n")
  sys.stderr.write("MD_atom_energy_fuzz=float (1.0e-12)\n")
  sys.stderr.write("\n")
  sys.stderr.write("energy_perturbation=float (0.0)\n")
  sys.stderr.write("profile=rank_to_profile\n")
  sys.stderr.write("2D=[ T | F ]\n")
  sys.stderr.write("debug=debug_level (0, <= 0 for no debugging tests/prints)\n")
  sys.stderr.write("snapshot_interval=int (1000, <=0 for no snapshots except final positions)\n")
  sys.stderr.write("delta_random_seed=seed_shift (-1, < 0 for seed from /dev/urandom)\n")

import re, math, time, os
import numpy as np, ase
try:
   import quippy
   have_quippy=True
except:
   have_quippy=False

try:
   from mpi4py import MPI
   comm = MPI.COMM_WORLD
   rank = comm.Get_rank()
   size = comm.Get_size()
except:
   comm = None
   rank = 0
   size = 1

if comm is not None and rank == 0:
   print "comm ", comm, " size ", size

def exit_error(message, stat):
   sys.stderr.write(message)
   try:
      comm.Abort(stat)
   except:
      pass
   sys.exit(stat)

# read inputs on root, then bcast
if rank == 0:
   lines=sys.stdin.readlines()
   if len(lines) == 0:
      try:
	 infile=open("ns_inputs","r")
      except:
	 exit_error("Failed to read ns_inputs file\n", 1)
      lines = infile.readlines()
   args={}
   if rank == 0:
      for line in lines:
	 if re.match("\s*(#.*)?$", line):
	    continue
	 matches = re.match("\s*(\S+)\s*=\s*(.*\S)", line)
	 if matches is None:
	    exit_error("Failed to parse line '%s'" % line, 1)
	 args[matches.group(1)] = matches.group(2)
else:
   args = None
if comm is not None:
   args = comm.bcast(args,root=0)

# parse args

# convert from strings to actual args
ns_args={}
try:
  ns_args['n_walkers'] = int(args.pop('n_walkers'))
except:
  exit_error("need number of walkers n_walkers\n",1)
try:
  ns_args['n_cull'] = int(args.pop('n_cull'))
except:
  exit_error("need number to cull n_cull\n",1)
try:
  ns_args['n_iter'] = int(args.pop('n_iter'))
except:
  exit_error("need number of NS iterations n_iter\n",1)
try:
  ns_args['initial_energy_ceiling'] = float(args.pop('initial_energy_ceiling'))
except:
  exit_error("need energy ceiling for initial distribution of configs initial_energy_ceiling\n",1)
try:
  ns_args['QUIP_pot_args'] = args.pop('QUIP_pot_args')
except:
  exit_error("need QUIP potential args QUIP_pot_args\n",1)
try:
  ns_args['QUIP_pot_params_file'] = args.pop('QUIP_pot_params_file')
except:
  exit_error("need QUIP potential params file QUIP_pot_params_file\n",1)

ns_args['start_file'] = args.pop('start_file', '')
ns_args['restart_file'] = args.pop('restart_file', '')
if ((ns_args['start_file'] == '' and ns_args['restart_file'] == '') or
    (ns_args['start_file'] != '' and ns_args['restart_file'] != '')):
   exit_error("Got both start_file and restart_file, conflicting\n", 3)

ns_args['out_file_prefix'] = args.pop('out_file_prefix', '')
if ns_args['out_file_prefix'] != '':
   ns_args['out_file_prefix'] += '.'
ns_args['profile'] = int(args.pop('profile', -1))
ns_args['debug'] = int(args.pop('debug', -1))
ns_args['snapshot_interval'] = int(args.pop('snapshot_interval', 1000))
ns_args['delta_random_seed'] = int(args.pop('delta_random_seed', -1))
ns_args['n_extra_walk_per_task'] = int(args.pop('n_extra_walk_per_task', 0))
ns_args['energy_perturbation'] = float(args.pop('energy_perturbation', 1.0e-14))

movement_args={}

movement_args['MC_atom_n_steps_expected'] = int(args.pop('MC_atom_n_steps_expected', 0))
movement_args['MC_atom_n_steps'] = int(args.pop('MC_atom_n_steps', 0))
movement_args['MC_atom_step_size'] = float(args.pop('MC_atom_step_size', 0.1))
movement_args['MC_atom_step_size_max'] = float(args.pop('MC_atom_step_size_max', 1.0))

movement_args['MD_atom_n_steps_expected'] = int(args.pop('MD_atom_n_steps_expected', 0))
movement_args['MD_atom_n_steps'] = int(args.pop('MD_atom_n_steps', 0))
movement_args['MD_atom_timestep'] = float(args.pop('MD_atom_timestep', 1.0))
movement_args['MD_atom_energy_fuzz'] = float(args.pop('MD_atom_energy_fuzz', 1.0e-12))

movement_args['MC_adjust_step_interval'] = int(args.pop('MC_adjust_step_interval', 10))

movement_args['2D'] = args.pop('2D', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]

confining_pot_args={}
confining_pot_args['mag'] = float(args.pop('confining_potential_mag', 0.0))

if 'QUIP_pot_params_file' in ns_args:
   if not have_quippy:
      exit_error("Got QUIP_pot_params but no quippy module\n", 3)
   try:
      if rank == 0:
	 ns_args['QUIP_pot_params'] = open(ns_args['QUIP_pot_params_file'],"r").read()
      else:
	 ns_args['QUIP_pot_params'] = None
      if comm is not None:
	 ns_args['QUIP_pot_params'] = comm.bcast(ns_args['QUIP_pot_params'], root=0)
   except:
      exit_error("Failed to read params file '%s'\n" % ns_args['QUIP_pot_params_file'], 1)
else:
   sys.stderr.write("Got no *_pot_params_file")

if len(args) > 0:
  exit_error(str(args)+"\nUnknown arguments read in\n", 2)

if rank == 0:
   print "ns_args ",ns_args
   print "movement_args ",movement_args

# initialise potential
if have_quippy:
   pot = quippy.Potential(ns_args['QUIP_pot_args'], param_str=ns_args['QUIP_pot_params'], calculation_always_required=True, cutoff_skin=1.0)
else:
   exit_error("Need some non-quippy way of initializing calculator\n",3)

# figure out numbers of local walkers
rank_of_walker = [0]*ns_args['n_walkers']
if size <= 1:
   n_walkers = ns_args['n_walkers']
else:
   n_walkers_per_task = ns_args['n_walkers']/size
   if n_walkers_per_task*size != ns_args['n_walkers']:
      exit_error("number of walkers %d not divisible by number of MPI processes %d\n" % (ns_args['n_walkers'], size), 5)
   last_walker = 0
   for i_rank in range(size):
      first_walker = last_walker
      last_walker = last_walker + n_walkers_per_task
      if last_walker > ns_args['n_walkers']:
	 last_walker = ns_args['n_walkers']
      if i_rank == rank:
	 n_walkers = last_walker-first_walker
	 my_first_walker = first_walker
	 my_last_walker = last_walker
      if last_walker > first_walker:
	 rank_of_walker[first_walker:last_walker] = [i_rank]*(last_walker-first_walker)

walkers=[]
if ns_args['restart_file'] == '': # start from scratch
   # read initial config
   if have_quippy:
      init_atoms = None
      if rank == 0:
	 if re.search('.xyz$', ns_args['start_file']) is not None:
	    # read config from an xyz file
	    init_atoms = quippy.Atoms(ns_args['start_file'])
	 else:
	    # create atoms structs from a list of atomic numbers and numbers of atoms
	    start_io=open(ns_args['start_file'],'r')
	    lattice=quippy.fzeros( (3,3) )
	    lattice[:,1] = [ float(s) for s in start_io.readline().split() ]
	    lattice[:,2] = [ float(s) for s in start_io.readline().split() ]
	    lattice[:,3] = [ float(s) for s in start_io.readline().split() ]
	    init_atoms=quippy.Atoms()
	    init_atoms.set_lattice(lattice)
	    for l in start_io.readlines():
	       Z = int(l.split()[0])
	       n = int(l.split()[1])
	       init_atoms.add_atoms([ [0.0]* n ] * 3, [Z]*n)
	    print "initial atoms created from a list"
	    init_atoms.write("stdout")
      if comm is not None:
	 init_atoms = comm.bcast(init_atoms, root=0)
      init_atoms.set_cutoff(pot.cutoff(), cutoff_skin=1.0)
   else:
      exit_error("need some non-quippy way of reading input configuration\n",3)

   # clone initial config into array of walkers
   if ns_args['debug'] >= 1 and have_quippy and size <= 1:
      init_atoms.params['n_walks'] = 0
   for i_walker in range(n_walkers):
     walkers.append(init_atoms.copy())
else: # doing a restart
   if have_quippy:
      if rank == 0: # read on head task and send to other tasks
	 l_walkers=[]
	 traj_io = quippy.CInOutput(ns_args['restart_file'], action=quippy.INPUT)
	 ar_iter = quippy.AtomsReader(traj_io).iterframes()
	 for r in range(size):
	    at_list=[]
	    for i in range(n_walkers):
	       if comm is None or r == 0:
		  walkers.append(ar_iter.next())
	       else:
		  at_list.append(ar_iter.next())
	    if r > 0:
	       comm.send(at_list, dest=r, tag=1)
	 traj_io.close()
      else: # receive from head task
	 walkers = comm.recv(source=0, tag=1)
   else:
      exit_error("need some non-quippy way of reading restart_file\n",3)

for at in walkers:
   at.set_velocities(np.zeros( (len(walkers[0]), 3) ))
   at.set_calculator(pot)

n_cull = ns_args['n_cull']
n_extra_walk_per_task = ns_args['n_extra_walk_per_task']

def eval_energy(at, PE_only=False):
  # potential
  if have_quippy:
      energy = at.get_potential_energy()
  else:
      sys.stderr.write("Need some non-quippy way to do eval_energy")

  # confining
  if confining_pot_args['mag'] > 0.0:
      energy += confining_pot_args['mag']*(np.linalg.norm(at.pos)**2)

  # kinetic
  if not PE_only:
     velocities = at.get_velocities()
     masses = at.get_masses()
     if velocities is not None and masses is not None:
	 energy += at.get_kinetic_energy()

  return energy

def quippy_propagate(at, dt, n_steps):
   old_velo = at.get_velocities()
   if old_velo is not None:
      if not hasattr(at, 'velo'):
	 at.add_property('velo', 0.0, n_cols=3)
      at.velo[:,:] = old_velo.transpose()/(ase.units.Ang/ase.units.fs)
   ds=quippy.DynamicalSystem(at)
   ds.run(pot, dt=dt/ase.units.fs, n_steps=n_steps, summary_interval=0, connect_interval=1, write_interval=0, save_interval=0)
   at.set_velocities(at.velo.transpose()*(ase.units.Ang/ase.units.fs))

def do_MD_atom_walk(at, movement_args, Emax):

   if confining_pot_args['mag'] > 0.0:
      exit_error("Can't do_MD_atom_walk with confining potential > 0.0\n", 4)

   if movement_args['MD_atom_n_steps'] <= 0:
      return

   #DEBUG global print_prefix
   #DEBUG print print_prefix, ": do_MD_atom_walk with Emax ", Emax # DEBUG

   #DEBUG print print_prefix, ": initial positions ", at.get_positions()[0]
   #DEBUG if at.get_velocities() is not None:
      #DEBUG print print_prefix, ": initial velo ", at.get_velocities()[0]
   #DEBUG else:
      #DEBUG print print_prefix, ": initial velo ", None
   #DEBUG print print_prefix, ": initial energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy() # DEBUG

   old_pos = at.get_positions()
   old_velo = at.get_velocities()
   if old_velo is None:
      old_velo = np.zeros( (len(at), 3) )

   masses = at.get_masses()
   unit_rv = np.random.standard_normal( (len(at), 3) )
   unit_rv /= np.linalg.norm(unit_rv)
   # mag_rv should have prob distrib p(r) = r^(3N-1) using transformation rule p(y) = p(x) |dx/dy|, with p(y) = y^{3N-1} and p(x) = 1
   mag_rv = np.random.uniform()**(1.0/(3.0*len(at)))
   pot_energy = at.get_potential_energy()
   # from Baldock thesis Eq. 11.10 
   #     p^{**} = r \mathbf{S} \hat{\mathbf{r}}
   # and 11.11 
   #     S_{ij} = \delta_{ij} (2 m_i [ E_{lim} - U(q))])^{1/2}
   # p_i = r (2 m_i)^{1/2} (E-U)^{1/2} \hat{r}_i
   # v_i = p_i / m_i = r (2/m)^{1/2} (E-U)^{1/2} \hat{r}_i
   if Emax > pot_energy:
      velocities = mag_rv * np.sqrt(2.0/np.array([masses,]*3).transpose()) * np.sqrt((Emax-pot_energy)) * unit_rv
   else: # should never happen - maybe it's happening because of MD_atom_energy_fuzz
      if rank == 0:
	 print "WARNING: got pot_energy ",pot_energy, " > Emax ",Emax, " in do_MD_atom_walk"
      velocities = 0.0 * unit_rv
   at.set_velocities(velocities)

   #DEBUG print print_prefix, ": masses for KE ",masses
   #DEBUG print print_prefix, ": velocities for KE ",at.get_velocities()
   #DEBUG print print_prefix, ": KE ",at.get_kinetic_energy()
   #DEBUG print print_prefix, ": mag_rv * mag_KE (eV) ", mag_rv**2 * (Emax-pot_energy)

   #DEBUG print print_prefix, ": mid energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy() # DEBUG

   # propagate in time
   if have_quippy:
      quippy_propagate(at, dt=movement_args['MD_atom_timestep'], n_steps=movement_args['MD_atom_n_steps']) 
   else:
      exit_error("Need some non-quippy way of doing MD\n",3)

   tot_e = eval_energy(at)
   if tot_e >= Emax+movement_args['MD_atom_energy_fuzz']:
      print print_prefix, ": WARNING reject MD traj Emax ", Emax, " total energy ", tot_e
      at.set_positions(old_pos)
      at.set_velocities(old_velo)

   #DEBUG print print_prefix, ": final energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy() #DEBUG
   #DEBUG print print_prefix, ": final positions ", at.get_positions()[0]
   #DEBUG print print_prefix, ": final velo ", at.get_velocities()[0]

def do_MC_atom_walk(at, movement_args, Emax):
   if movement_args['MC_atom_n_steps'] <= 0: 
      return None
   #DEBUG print print_prefix, ": do_MC_atom_walk"
   n_steps = movement_args['MC_atom_n_steps']
   step_size = movement_args['MC_atom_step_size']
   #DEBUG print print_prefix, ": do_MC_atom_walk step_size ", step_size
   accept_num=0
   energy = eval_energy(at)
   #DEBUG print print_prefix, ": MC_walk initial energy, Emax ", energy, Emax # DEBUG
   dz=0.0
   for i_MC_step in range(n_steps):
      #DEBUG print "i_MC_step ",i_MC_step
      at_list=list(range(len(at)))
      np.random.shuffle(at_list)
      for i_at in at_list:
	 #DEBUG print "i_at ",i_at
	 dx = np.random.normal(0.0, step_size)
	 dy = np.random.normal(0.0, step_size)
	 if not movement_args['2D']:
	    dz = np.random.normal(0.0, step_size)
	 old_energy = energy
	 old_pos = at.get_positions()
	 new_pos = old_pos.copy()
	 new_pos[i_at,:] += (dx, dy,dz)
	 at.set_positions(new_pos)
	 energy = eval_energy(at)
	 if energy >= Emax:
	    # reject move
	    at.set_positions(old_pos)
	    energy = old_energy
	 else:
	    accept_num += 1
   #DEBUG last_energy = eval_energy(at)
   #DEBUG print print_prefix, ": MC_walk final energy, accept_rate ", energy, last_energy, float(accept_num)/float(n_steps*len(at)) #DEBUG
   return float(accept_num)/float(n_steps*len(at))

def walk_single_walker(at, movement_args, Emax):
   #DEBUG print print_prefix, ": walk_single_walker initial E", eval_energy(at) # DEBUG
   atom_accept_rate = do_MC_atom_walk(at, movement_args, Emax)
   #DEBUG print print_prefix, ": walk_single_walker mid E", eval_energy(at) # DEBUG
   do_MD_atom_walk(at, movement_args, Emax)
   ## cell_accept_rate = do_MC_cell_step(at, movement_args, Emax)
   cell_accept_rate = None
   ##
   if hasattr(at, 'n_walks') and size <= 1:
      at.n_walks += 1
   #DEBUG print print_prefix, ": walk_single_walker acc rates ", atom_accept_rate, cell_accept_rate
   #DEBUG print print_prefix, ": walk_single_walker final E", eval_energy(at) # DEBUG
   return (atom_accept_rate, cell_accept_rate)

def max_energy(walkers, n):
   # do local max
   energies_loc = np.array([ eval_energy(at)+np.random.uniform(-1.0,0.0)*ns_args['energy_perturbation'] for at in walkers])
   energies = np.array(comm.allgather(energies_loc)).flatten()
   #DEBUG print print_prefix , ": max_energies energies ",energies
   #DEBUG print print_prefix , ": max_energies energies.argsort() ",energies.argsort()

   Emax_ind = energies.argsort()[-1:-n-2:-1]
   Emax = energies[Emax_ind]
   # WARNING: currently assumes that each node has equal number of walkers
   rank_of_max = np.floor(Emax_ind/len(walkers)).astype(int)

   return (Emax[0:-1], np.mod(Emax_ind[0:-1],len(walkers)), rank_of_max[0:-1], Emax[-1])

def adjust_MC_steps(atom_accept_rate_sum, cell_accept_rate_sum, n_entries, comm):
   atom_accept_rate=None
   if atom_accept_rate_sum is not None:
      atom_accept_rate = comm.allreduce(atom_accept_rate_sum,MPI.SUM)/float(n_entries*size)

   cell_accept_rate=None
   if cell_accept_rate_sum is not None:
      cell_accept_rate = comm.allreduce(cell_accept_rate_sum,MPI.SUM)/float(n_entries*size)

   if rank == 0:
      if atom_accept_rate is not None or cell_accept_rate is not None:
	 print "adjust_MC_steps mean rates atom ", atom_accept_rate, " cell ", cell_accept_rate

   if atom_accept_rate is not None:
      atom_dir=''
      if atom_accept_rate < 0.25:
	 movement_args['MC_atom_step_size'] /= 1.2
	 atom_dir='down'
      if atom_accept_rate > 0.75:
	 movement_args['MC_atom_step_size'] *= 1.2
	 atom_dir='up'
      ## need to do cell steps

      if movement_args['MC_atom_step_size'] > movement_args['MC_atom_step_size_max']:
	 movement_args['MC_atom_step_size'] = movement_args['MC_atom_step_size_max']
	 if rank == 0:
	    print "adjust_MC_steps maxed out MC_atom_step_size=", movement_args['MC_atom_step_size'] 

      if atom_dir != "" and rank == 0:
	 print "adjust MC_atom_step_size ",atom_dir," to ", movement_args['MC_atom_step_size']

   #### if cell_accept_rate is not None:

prev_snapshot = None
# do NS
def do_ns_loop():

   global print_prefix

   if rank == 0:
      nD = 3
      if movement_args['2D']:
	 nD = 2
      energy_io.write("%d %d %d\n" % (ns_args['n_walkers'], ns_args['n_cull'], len(walkers[0])*nD) )

   # Counting on conventional RNG and /dev/urandom here.  Should at least use a real parallel RNG
   if ns_args['delta_random_seed'] > 0:
      np.random.seed(rank+ns_args['delta_random_seed'])
   else:
      np.random.seed()
   if rank == 0: # share a common random state
      common_random_state = np.random.get_state()
      common_random_state = comm.bcast(common_random_state, root=0)
      # now back to local unique seed for rank=0
      if ns_args['delta_random_seed'] > 0:
	 np.random.seed(size+ns_args['delta_random_seed'])
      else:
	 np.random.seed()
   else:
      # share a common random state
      common_random_state = None
      common_random_state = comm.bcast(common_random_state, root=0)

   ## print print_prefix, ": random state ", np.random.get_state()
   ## if rank == 0:
      ## print print_prefix, ": common random state ", common_random_state

   if ns_args['debug'] >= 1 and size <= 1:
      n_walks_history = []

   max_n_cull_per_task = int(n_cull/size)
   if max_n_cull_per_task * size != n_cull:
      max_n_cull_per_task += 1
   #DEBUG print print_prefix, ": max_n_cull_per_task ", max_n_cull_per_task

   # figure out n_steps to walk on each iteration to get correct expected number
   def set_n_steps(prop):
      if movement_args[prop+'_expected'] > 0:
	 if movement_args[prop] > 0:
	    exit_error("Got both "+prop+" and "+prop+"_expected, conflict\n", 5)

	 if max_n_cull_per_task*size == n_cull and n_extra_walk_per_task == 0: # no extra walkers
	    movement_args[prop] = movement_args[prop+'_expected']
	    if rank == 0:
	       print "Calculating n_walks, trivial since there are no extra walkers"
	 else:
	    # f_c = n_c/n_t [ fraction of total that are culled (and walked once)]
	    # f_e = n_e/(n_t-n_c) [fraction of ones that aren't culled that are also walked ]

	    # n(1) <- f_c n_t + (1-f_c)*(1-f_e) n(1)
	    # n(l >= 2) <- (1-f_c)(1-f_e) n(l) + (1-f_c) f_e n(l-1)

	    # f = (1-f_c)f_e / (f_c+f_e-f_c f_e)

	    # n(1)/n_t = f_c/(1-(1-f_c)(1-f_e)) = f_c/(f_c+f_e-f_c f_e)
	    # n(l >= 2)/n_t = f n(l-1) = f^(l-1) n(1)/n_t
	    # n_walks = n(1)/n_t + sum_{l=2}^\infty l n(l)/n_t
	    #         = n(1)/n_t (1 + sum_{l=2}^\infty l f^{l-1})
	    #         = n(1)/n_t (1 + \sum{l=1}^\infty (l+1) f^l)
	    #         = n(1)/n_t (1 + \sum f^l + sum l f^l)
	    #         = n(1)/n_t (1 + f/(1-f) + f/(1-f)**2

	    f_cull = float(n_cull)/float(ns_args['n_walkers'])
	    f_extra = float( (max_n_cull_per_task*size-n_cull) + n_extra_walk_per_task*size ) / float(ns_args['n_walkers']-n_cull)
	    f = (1.0-f_cull)*f_extra/(f_cull+f_extra-f_cull*f_extra)

	    n_walks = f_cull/(f_cull+f_extra-f_cull*f_extra) * (1.0 + f/(1.0-f) + f/(1.0-f)**2)
	    if rank == 0:
	       print "Calculated n_walks =",n_walks, " from f_cull ",f_cull," f_extra ",f_extra
	    movement_args[prop] = int(math.ceil(movement_args[prop+'_expected']/n_walks))
	    
      else:
	 if movement_args[prop] > 0 and rank == 0:
	    print "WARNING: using absolute number of "+prop

   set_n_steps('MC_atom_n_steps')
   set_n_steps('MD_atom_n_steps')

   if  rank == 0:
      print "Using calculated number of MC_atom_n_steps ", movement_args['MC_atom_n_steps']
      print "Using calculated number of MD_atom_n_steps ", movement_args['MD_atom_n_steps']

   if ns_args['restart_file'] == '': # not a restart
      # initial positions are just random
      for at in walkers:
	 at.set_scaled_positions( np.random.uniform(0.0, 1.0, (len(at),3) ) )
	 energy = eval_energy(at)
	 while math.isnan(energy) or energy > ns_args['initial_energy_ceiling']:
	    at.set_scaled_positions( np.random.uniform(0.0, 1.0, (len(at),3) ) )
	    energy = eval_energy(at)

   for at in walkers:
      print rank, ": initial energy ", eval_energy(at)

   atom_accept_rate_sum = None
   cell_accept_rate_sum = None
   accept_rate_n = 0

   prev_time = -1

   Emax_of_step = None

   verbose=False
   for i_ns_step in range(ns_args['n_iter']):
      print_prefix="%d %d" % (rank, i_ns_step)

      #DEBUG if rank == 0: # DEBUG
	 #DEBUG print "starting ns loop ",i_ns_step # DEBUG

      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_TE START 00 ",i_ns_step, [ eval_energy(at) for at in walkers ]
      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_PE START 01 ",i_ns_step, [ eval_energy(at, True) for at in walkers ]


      #DEBUG (Emax, cull_ind, cull_rank, Emax_next) = max_energy(walkers, 10)
      #DEBUG if rank == 0:
	 #DEBUG print print_prefix, ": top 10 energies ", Emax
	 #DEBUG print print_prefix, ": top 10 energy indices ", cull_ind

      # do NS config dropping/forming
      (Emax, cull_ind, cull_rank, Emax_next) = max_energy(walkers, n_cull)
      if Emax_of_step is not None and rank == 0 and Emax[0] > Emax_of_step+movement_args['MD_atom_energy_fuzz']:
	 print print_prefix, "WARNING: energy above Emax ", Emax_of_step, " bad energies: ", Emax[np.where(Emax > Emax_of_step+movement_args['MD_atom_energy_fuzz'])]

      cull_list=[None] * size
      for r in range(size):
	 entries_for_this_rank = np.where(cull_rank == r)[0]
	 cull_list[r] = cull_ind[entries_for_this_rank]

      #DEBUG print print_prefix, ": got Emax ", Emax
      #DEBUG print print_prefix, ": orig cull list ", cull_list

      if (i_ns_step > 0 and Emax_next >= Emax_of_step) and rank == 0:
	 print "WARNING: Emax not decreasing ",Emax_of_step, Emax_next
      Emax_of_step=Emax_next
      if rank == 0 and (time.time() > prev_time+60 or (i_ns_step % max(int(ns_args['n_iter']/1000),1) or i_ns_step == ns_args['n_iter']) == 0):
        print i_ns_step, "Emax_of_step ", Emax_of_step
	prev_time = time.time()

      # record Emax walkers energies and configurations
      if rank == 0:
	 for E in Emax:
	    energy_io.write("%d %.60f\n" % (i_ns_step, E))
	 energy_io.flush()
      if cull_list[rank] is not None:
	 for i in cull_list[rank]:
	    #DEBUG print print_prefix, ": writing walker ",i
	    if have_quippy:
	       walkers[i].write(traj_io)
	    else:
	       exit_error("Need some non-quippy way of writing trajectory\n",3)

      # calculate how many will be culled on each rank
      n_cull_of_rank = np.array([ sum(cull_rank == r) for r in range(size) ])

      # label configs to be culled
      status = np.empty( (size, n_walkers), np.object_)
      status[:,:] = ''
      for r in range(size):
	 status[r,cull_ind[np.where(cull_rank == r)[0]]] = 'c_t'

      if ns_args['debug'] >= 1:
	 initial_PE_loc = [ eval_energy(at, True) for at in walkers ]
	 initial_PE = np.array(comm.allgather(initial_PE_loc)).flatten()
	 initial_changed = initial_PE[np.where(status.flatten() == 'c_t')]
	 initial_unchanged = initial_PE[np.where(status.flatten() == '')]

      if ns_args['debug'] >= 3:
	 for r in range(len(status)):
	    print print_prefix, ": initial status ", r, [ s for s in status[r,:] ]

      # find load balance by cloning on top of excess maxima
      recv_ind=[]
      recv_rank=[]
      send_ind=[]
      send_rank=[]
      cull_inds_to_remove=[]

      for r in range(size):
	 #DEBUG print print_prefix, ": load balance for rank ", r
	 for dr in np.array(zip(np.array(range(1,size)), -np.array(range(1,size)))).flatten():
	    if n_cull_of_rank[r] <= max_n_cull_per_task: # not too many to be culled on this rank
	       break
	    # this rank has too many to cull, must receive replacement from another node
	    remote_r = (r+dr) % size
	    #DEBUG print print_prefix, ": check tranfer to ", remote_r
	    if n_cull_of_rank[remote_r] < max_n_cull_per_task: # send from r+dr to r
	       n_transfer = min(n_cull_of_rank[r]-max_n_cull_per_task, max_n_cull_per_task-n_cull_of_rank[remote_r])
	       #DEBUG print print_prefix, ": got n_tranfer ", n_transfer
	       recv_rank.extend([r]*n_transfer)
	       send_rank.extend([remote_r]*n_transfer)
	       local_ind = np.where(status[r,:] == 'c_t')[0][0:n_transfer]
	       recv_ind.extend(local_ind)
	       remote_ind = np.where(status[remote_r,:] == '')[0][0:n_transfer]
	       send_ind.extend(remote_ind)
	       status[r,local_ind] = 'c_s'
	       status[remote_r,remote_ind] = 'c_t_a'
	       n_cull_of_rank[r] -= n_transfer
	       n_cull_of_rank[remote_r] += n_transfer

      #DEBUG for r in range(len(status)):
	 #DEBUG print print_prefix, ": post-cull-load-balance status ", r, status[r]

      # save local random state, and switch to common one
      local_random_state = np.random.get_state()
      np.random.set_state(common_random_state)

      # select clones
      for r in range(size):
	 #DEBUG print print_prefix, ": finding clones for rank ",r
	 list_clone_target = np.where(status[r,:] == 'c_t')[0]
	 #DEBUG print print_prefix, ": list_clone_target ", list_clone_target
	 n_clone_target = len(list_clone_target)
	 n_avail = sum(status[r,:] == '')
	 # do remote clones
	 n_remaining_clones = n_clone_target
	 while n_remaining_clones > 0:
	    remote_r = np.random.randint(size)
	    n_avail_remote = sum(status[remote_r,:] == '')
	    #DEBUG print print_prefix, ": check transfer to rank ", remote_r, " remote status ", status[remote_r,:], " n_avail_remote ",n_avail_remote
	    if n_avail_remote > 0: # something is available on remote_r
	       # send from random avail walker on remote_r to clone_target on r
	       n_transfer = min(n_remaining_clones, n_avail_remote)

	       #DEBUG print print_prefix, ": n_transfer ", n_transfer

	       # set ranks
	       send_rank.extend([remote_r]*n_transfer)
	       recv_rank.extend([r]*n_transfer)

	       # set indices
	       r_is = []
	       for ii in range(n_transfer):
		  r_i = np.random.randint(0, n_walkers)
		  while status[remote_r,r_i] != '':
		     r_i = np.random.randint(0, n_walkers)
		  # now r_i should be something with status ''
		  #DEBUG print print_prefix, ": cloning from ", remote_r, r_i, " status ",status[remote_r, r_i]
		  status[remote_r,r_i] = 'c_s'
		  r_is.append(r_i)
	       send_ind.extend(r_is)

	       list_clone_target = np.where(status[r,:] == 'c_t')[0]
	       status[r,list_clone_target[0:n_transfer]] = 'c_t_a'
	       recv_ind.extend(list_clone_target[0:n_transfer])

	       n_remaining_clones -= n_transfer
	       #DEBUG print print_prefix, ": n_remaining_clones ", n_remaining_clones

      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_PE POST_LOC_CLONE 15 ",i_ns_step, [ eval_energy(at, True) for at in walkers ]

      # make into numpy arrays so that mathematical operations will work
      send_rank = np.array(send_rank)
      send_ind = np.array(send_ind)
      recv_rank = np.array(recv_rank)
      recv_ind = np.array(recv_ind)

      # save new common state, and restore to local state
      common_random_state = np.random.get_state()
      np.random.set_state(local_random_state)

      #DEBUG for r in range(len(status)):
	 #DEBUG print print_prefix, ": post-cloning status ", r, status[r]


      # create sending/receiving buffers
      #DEBUG print print_prefix, ": recv_rank ", recv_rank
      #DEBUG print print_prefix, ": recv_ind ", recv_ind
      #DEBUG print print_prefix, ": send_rank ", send_rank
      #DEBUG print print_prefix, ": send_ind ", send_ind
      # create sending/receiving buffers
      pos_send_buf=[None] * size
      vel_send_buf=[None] * size
      cell_send_buf=[None] * size
      for i in np.where(send_rank == rank)[0]:
	 r_recv = recv_rank[i]
	 i_send = send_ind[i]
	 #DEBUG print print_prefix, ": sending to ",r_recv," from index ",i_send
	 if pos_send_buf[r_recv] is None:
	    pos_send_buf[r_recv] = []
	 if vel_send_buf[r_recv] is None:
	    vel_send_buf[r_recv] = []
	 if cell_send_buf[r_recv] is None:
	    cell_send_buf[r_recv] = []
	 pos_send_buf[r_recv].append(walkers[i_send].get_positions())
	 vel_send_buf[r_recv].append(walkers[i_send].get_velocities())
	 cell_send_buf[r_recv].append(walkers[i_send].get_cell())

      #DEBUG print print_prefix, ": pos_send_buf ", pos_send_buf
      #DEBUG print print_prefix, ": vel_send_buf ", vel_send_buf
      #DEBUG print print_prefix, ": cell_send_buf ", cell_send_buf

      # do communication
      pos_recv_buf = comm.alltoall(pos_send_buf)
      vel_recv_buf = comm.alltoall(vel_send_buf)
      cell_recv_buf = comm.alltoall(cell_send_buf)

      # copy from receive buffers into walkers structure
      my_recv_ind = np.array(recv_ind)[np.where(np.array(recv_rank) == rank)[0]]
      #DEBUG print print_prefix, ": my_recv_ind ", my_recv_ind
      recv_i = 0
      for (pos_array, vel_array, cell_array) in zip(pos_recv_buf, vel_recv_buf, cell_recv_buf):
	 #DEBUG print print_prefix, ": received pos_array from rank", pos_array 
	 #DEBUG print print_prefix, ": received cell_array from rank", cell_array 
	 if pos_array is not None:
	    for (pos_entry, vel_entry, cell_entry) in zip(pos_array, vel_array, cell_array):
	       #DEBUG print print_prefix, ": pos_entry ",pos_entry
	       #DEBUG print print_prefix, ": cell_entry ",cell_entry
	       #DEBUG print print_prefix, ": copying received config to index ",my_recv_ind[recv_i]
	       walkers[my_recv_ind[recv_i]].set_positions(pos_entry)
	       walkers[my_recv_ind[recv_i]].set_velocities(vel_entry)
	       walkers[my_recv_ind[recv_i]].set_cell(cell_entry)
	       recv_i += 1

      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_PE POST_CLONE 20 ",i_ns_step, [ eval_energy(at, True) for at in walkers ]

      # move cloned walkers
      #DEBUG for at in walkers:
	#DEBUG print print_prefix, ": pre-move walkers", at.get_positions()[0]
      #DEBUG print print_prefix, ": pre-move energies", [ eval_energy(at) for at in walkers ]

      # walk clone targets
      #DEBUG print print_prefix, ": status[rank,:] ",status[rank,:]
      clone_walk_ind = np.where(status[rank,:] == 'c_t_a')[0]
      for i_at in clone_walk_ind:
	 #DEBUG print print_prefix, ": walk clone ", i_at
	 (atom_accept_rate, cell_accept_rate) = walk_single_walker(walkers[i_at], movement_args, Emax_of_step)
	 accept_rate_n += 1
	 if atom_accept_rate is not None:
	    if atom_accept_rate_sum is None:
	       atom_accept_rate_sum = atom_accept_rate
	    else:
	       atom_accept_rate_sum += atom_accept_rate
	 if cell_accept_rate is not None:
	    if cell_accept_rate_sum is None:
	       cell_accept_rate_sum = cell_accept_rate
	    else:
	       cell_accept_rate_sum += cell_accept_rate

      # check that everything that should have been changed has, and things that shouldn't have, haven't
      if ns_args['debug'] >= 1:
	 final_PE_loc = [ eval_energy(at, True) for at in walkers ]
	 final_PE = np.array(comm.allgather(final_PE_loc)).flatten()
	 if rank == 0:
	    final_status = status.flatten()
	    for e in initial_unchanged:
	       if e not in final_PE:
		  print "initial_PE ", initial_PE
		  print "final_PE ", final_PE
		  print "final_status ", final_status
		  print "WARNING energy that should have been unchanged ", e," missing from final energies"
	    for e in initial_changed:
	       if e in final_PE:
		  print "initial_PE ", initial_PE
		  print "final_PE ", final_PE
		  print "final_status ", final_status
		  print "WARNING: energy that should have been changed ", e," still there in final energies"

      #DEBUG print print_prefix, ": before extra walks # ", max_n_cull_per_task - len(clone_walk_ind)
      #DEBUG print print_prefix, ": before extra walks status ", status[rank, r_i]

      # walk extras
      for ii in range(max_n_cull_per_task - len(clone_walk_ind)+n_extra_walk_per_task):
	 r_i = np.random.randint(0, n_walkers)
	 while status[rank,r_i] != '' and status[rank,r_i] != 'c_s':
	    r_i = np.random.randint(0, n_walkers)
	 #DEBUG print print_prefix, ": walk extra ", r_i # DEBUG
	 (atom_accept_rate, cell_accept_rate) = walk_single_walker(walkers[r_i], movement_args, Emax_of_step)
	 accept_rate_n += 1
	 if atom_accept_rate is not None:
	    if atom_accept_rate_sum is None:
	       atom_accept_rate_sum = atom_accept_rate
	    else:
	       atom_accept_rate_sum += atom_accept_rate
	 if cell_accept_rate is not None:
	    if cell_accept_rate_sum is None:
	       cell_accept_rate_sum = cell_accept_rate
	    else:
	       cell_accept_rate_sum += cell_accept_rate
	 # this status will be set only on this MPI task
	 status[rank,r_i] = 'e_w'

      if i_ns_step % movement_args['MC_adjust_step_interval'] == movement_args['MC_adjust_step_interval']-1:
	 adjust_MC_steps(atom_accept_rate_sum, cell_accept_rate_sum, accept_rate_n, comm)
	 if atom_accept_rate_sum is not None:
	    atom_accept_rate_sum = 0.0
	 if cell_accept_rate_sum is not None:
	    cell_accept_rate_sum = 0.0
	 accept_rate_n = 0

      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_PE END 30 ",i_ns_step, [ eval_energy(at,True) for at in walkers ]
      if ns_args['debug'] >= 2:
	 print print_prefix, ": LOOP_TE END 31 ",i_ns_step, [ eval_energy(at) for at in walkers ]

      if ns_args['debug'] >= 3:
	 for r in range(len(status)):
	    print print_prefix, ": final status ", r, [ s for s in status[r,:] ]

      if ns_args['snapshot_interval'] > 0 and i_ns_step % ns_args['snapshot_interval'] == ns_args['snapshot_interval']-1:
	 if have_quippy:
	    snapshot_io = quippy.CInOutput(ns_args['out_file_prefix']+'snapshot.%d.%d.xyz' % (i_ns_step,rank), action=quippy.OUTPUT)
	    for at in walkers:
		  at.write(snapshot_io)
	    snapshot_io.close()
	 else:
	    exit_error("Need some non-quippy way of writing trajectory\n",3)
	 global prev_snapshot
	 if prev_snapshot is not None:
	    os.remove(ns_args['out_file_prefix']+'snapshot.%d.%d.xyz' % (prev_snapshot, rank))
	 prev_snapshot = i_ns_step

      #DEBUG for at in walkers:
	#DEBUG print print_prefix, ": post-move walkers", at.get_positions()[0]
      #DEBUG print print_prefix, ": post-move energies", [ eval_energy(at) for at in walkers ]

traj_io = quippy.CInOutput(ns_args['out_file_prefix']+'traj.%d.xyz' % rank, action=quippy.OUTPUT)
if rank == 0:
   energy_io = open(ns_args['out_file_prefix']+'energies', 'w')

if ns_args['profile'] == rank:
   import cProfile
   cProfile.run('do_ns_loop')
else:
   do_ns_loop()

# cleanup post loop
if have_quippy:
   snapshot_io = quippy.CInOutput(ns_args['out_file_prefix']+'snapshot.final.%d.xyz' % rank, action=quippy.OUTPUT)
   for at in walkers:
	 at.write(snapshot_io)
   snapshot_io.close()
else:
   exit_error("Need some non-quippy way of writing trajectory\n",3)
if prev_snapshot is not None:
   os.remove(ns_args['out_file_prefix']+'snapshot.%d.%d.xyz' % (prev_snapshot, rank))

for at in walkers:
   print rank, ": final energy ", eval_energy(at)

if rank == 0:
   energy_io.close()
traj_io.close()

MPI.Finalize()
sys.exit(0)
