#!/usr/bin/env python

import sys

print_prefix=""

def usage():
  sys.stderr.write("Usage: %s [ -no_mpi ] < input\n" % sys.argv[0])
  sys.stderr.write("input:\n")
  sys.stderr.write("start_volume_per_atom=float (initial simulation box volume per atom. Mutually exclusive with restart_*, one is required)\n")
  sys.stderr.write("start_species=int int [ float ] [, int int [ float ] ... ] (atomic_number multiplicity mass (amu). Info repeated for each species, separated by commas, mass is optional. Mutually exclusive with restart_*, one is required\n")
  sys.stderr.write("start_energy_ceiling=float (max energy for initial configs.  Initial P*V is added to this automatically. Mutually exclusive with restart_*, one is required.)\n")
  sys.stderr.write("restart_file=path_to_file.xyz (file for restart configs. Mutually exclusive with start_*, one is required)\n")
  sys.stderr.write("restart_first_iter=int (>=0, iteration being restarted from. Mutually exclusive with start_*, one is required\n")
  sys.stderr.write("n_walkers=int (MANDATORY)\n")
  sys.stderr.write("n_cull=int (MANDATORY)\n")
  sys.stderr.write("n_extra_walk_per_task=int (0)\n")
  sys.stderr.write("n_iter_per_walker=int (MANDATORY)\n")
  sys.stderr.write("min_Emax=float (None.  Termination condition based on Emax)\n")
  sys.stderr.write("out_file_prefix=str (None)\n")
  sys.stderr.write("energy_calculator= ( quip | lammps | internal | fortran) (fortran)\n")
  sys.stderr.write("\n")
  sys.stderr.write("atom_n_steps_expected=int (0, this or atom_n_steps required)\n")
  sys.stderr.write("atom_n_steps=int (0, this or atom_n_steps_expected required)\n")
  sys.stderr.write("atom_n_substeps=int (10, number of steps (MC sweeps or MD time steps in each segement))\n")
  sys.stderr.write("cell_n_substeps=int (1, number of MC sweeps in each segement)\n")
  sys.stderr.write("\n")
  sys.stderr.write("random_energy_perturbation=float (1.0e-12)\n")
  sys.stderr.write("atom_algorithm=[MC | MD] (MANDATORY)\n")
  sys.stderr.write("\n")
  sys.stderr.write("MC_atom_velocities=[T | F] (F, supported only for energy_calculator=fortran)\n")
  sys.stderr.write("MC_atom_velocities_pre_perturb=[T | F] (F)\n")
  sys.stderr.write("MC_atom_step_size=float (0.1)\n")
  sys.stderr.write("MC_atom_step_size_max=float (1.0)\n")
  sys.stderr.write("MC_atom_velo_step_size=float (0.1)\n")
  sys.stderr.write("MC_atom_velo_step_size_max=float (1.0)\n")
  sys.stderr.write("MC_atom_uniform_rv=[T | F] (F)\n")
  sys.stderr.write("\n")
  sys.stderr.write("MD_atom_velo_perturb=float (0.1, < 0 for completely randomizing rather than perturbing)\n")
  sys.stderr.write("MD_atom_timestep=float (1.0)\n")
  sys.stderr.write("MD_atom_timestep_max=float (2.0)\n")
  sys.stderr.write("MD_atom_energy_fuzz=float (1.0e-2)\n")
  sys.stderr.write("MD_atom_reject_energy_violation=[ T | F ] (F, use energy conservation violation (exceeding MD_atom_energy_fuzz) to reject MD trajectories)\n")
  sys.stderr.write("\n")
  sys.stderr.write("\n")
  sys.stderr.write("MC_cell_P=float (0.0)\n")
  sys.stderr.write("MC_cell_volume_step_size=float (0.01)\n")
  sys.stderr.write("MC_cell_volume_step_size_max=float (0.05)\n")
  sys.stderr.write("MC_cell_volume_prob=float (1.0)\n")
  sys.stderr.write("MC_cell_stretch_step_size=float (0.01)\n")
  sys.stderr.write("MC_cell_stretch_step_size_max=float (0.05)\n")
  sys.stderr.write("MC_cell_stretch_prob=float (1.0)\n")
  sys.stderr.write("MC_cell_shear_step_size=float (0.01)\n")
  sys.stderr.write("MC_cell_shear_step_size_max=float (0.05)\n")
  sys.stderr.write("MC_cell_shear_prob=float (1.0)\n")
  sys.stderr.write("MC_cell_min_aspect_ratio=float (0.5)\n")
  sys.stderr.write("MC_cell_max_volume_per_atom=float (1.0e3)\n")
  sys.stderr.write("\n")
  sys.stderr.write("adjust_step_interval=int (-10, negative for only using last iteration, 0 for no adjust)\n")
  sys.stderr.write("MC_adjust_step_factor=int (2.0)\n")
  sys.stderr.write("MD_adjust_step_factor=int (1.5)\n")
  sys.stderr.write("\n")
  sys.stderr.write("QUIP_pot_args=str (MANDATORY if energy_calculator=QUIP)\n")
  sys.stderr.write("QUIP_pot_params_file=str (MANDATORY if energy_calculator=QUIP)\n")
  sys.stderr.write("FORTRAN_model=str (MANDATORY if energy_calculator=QUIP)\n")
  sys.stderr.write("\n")
  sys.stderr.write("rng=( numpy | internal | rngstream ) (numpy)\n") # julia
  sys.stderr.write("profile=rank_to_profile (-1)\n")
  sys.stderr.write("2D=[ T | F ] (F, unsupported)\n")
  sys.stderr.write("debug=debug_level (0, <= 0 for no debugging tests/prints)\n")
  sys.stderr.write("snapshot_interval=int (1000, <=0 for no snapshots except final positions)\n")
  sys.stderr.write("delta_random_seed=seed_shift (-1, < 0 for seed from /dev/urandom)\n")
  sys.stderr.write("no_extra_walks_at_all=[ T | F ] (F)\n")

if len(sys.argv) != 1 and len(sys.argv) != 2:
   usage()
   sys.exit(1)

use_mpi=True
if len(sys.argv) == 2:
   if sys.argv[1] == "-no_mpi":
      use_mpi=False
   else:
      usage()
      sys.exit(1)

import re, math, time, os
import numpy as np, ase, ase.io
try:
   import quippy
   have_quippy=True
except:
   have_quippy=False

comm = None
rank = 0
size = 1
if use_mpi:
   try:
      from mpi4py import MPI
      comm = MPI.COMM_WORLD
      rank = comm.Get_rank()
      size = comm.Get_size()
   except:
      pass

if comm is not None and rank == 0:
   print "comm ", comm, " size ", size

def exit_error(message, stat):
   sys.stderr.write(message)
   try:
      comm.Abort(stat)
   except:
      pass
   sys.exit(stat)

# read inputs on root, then bcast
if rank == 0:
   lines=sys.stdin.readlines()
   if len(lines) == 0:
      try:
	 infile=open("ns_inputs","r")
      except:
	 exit_error("Failed to read ns_inputs file\n", 1)
      lines = infile.readlines()
   args={}
   if rank == 0:
      for line in lines:
	 if re.match("\s*(#.*)?$", line):
	    continue
	 matches = re.match("\s*(\S+)\s*=\s*(.*\S)", line)
	 if matches is None:
	    exit_error("Failed to parse line '%s'" % line, 1)
	 args[matches.group(1)] = matches.group(2)
else:
   args = None
if comm is not None:
   args = comm.bcast(args,root=0)

# parse args
ns_args={}

# convert from strings to actual args
try:
  ns_args['n_walkers'] = int(args.pop('n_walkers'))
except:
  exit_error("need number of walkers n_walkers\n",1)

try:
  ns_args['n_cull'] = int(args.pop('n_cull'))
except:
  exit_error("need number to cull n_cull\n",1)

try:
  ns_args['n_iter_per_walker'] = int(args.pop('n_iter_per_walker'))
except:
  exit_error("need number of iterations n_iter_per_walker\n",1)
ns_args['n_iter'] = ns_args['n_iter_per_walker']*ns_args['n_walkers']

try:
   ns_args['min_Emax'] = float(args.pop('min_Emax'))
except:
   ns_args['min_Emax'] = None

ns_args['start_volume_per_atom'] = float(args.pop('start_volume_per_atom', 0.0))
ns_args['restart_file'] = args.pop('restart_file', '')
if ((ns_args['start_volume_per_atom'] == 0.0 and ns_args['restart_file'] == '') or
    (ns_args['start_volume_per_atom'] != 0.0 and ns_args['restart_file'] != '')):
   exit_error("Got neither or both (conflicting) start_volume and restart_file\n", 3)

if ns_args['start_volume_per_atom'] != 0.0:
   try:
     ns_args['start_species'] = args.pop('start_species')
   except:
     exit_error("need species for initial configs start_species\n",1)
   try:
     ns_args['start_energy_ceiling'] = float(args.pop('start_energy_ceiling'))
   except:
     exit_error("need energy ceiling for initial distribution of configs start_energy_ceiling\n",1)

if ns_args['restart_file'] != '':
   try:
     ns_args['restart_first_iter'] = int(args.pop('restart_first_iter'))
   except:
     exit_error("need initial iteration restart_first_iter\n",1)

ns_args['out_file_prefix'] = args.pop('out_file_prefix', '')
if ns_args['out_file_prefix'] != '':
   ns_args['out_file_prefix'] += '.'
ns_args['profile'] = int(args.pop('profile', -1))
ns_args['debug'] = int(args.pop('debug', -1))
ns_args['snapshot_interval'] = int(args.pop('snapshot_interval', 1000))
ns_args['delta_random_seed'] = int(args.pop('delta_random_seed', -1))
ns_args['n_extra_walk_per_task'] = int(args.pop('n_extra_walk_per_task', 0))
ns_args['random_energy_perturbation'] = float(args.pop('random_energy_perturbation', 1.0e-12))

# parse energy_calculator
ns_args['energy_calculator'] = args.pop('energy_calculator', 'fortran')
do_calc_quip = False
do_calc_lammps = False
do_calc_internal = False
do_calc_fortran = False
if ns_args['energy_calculator'] == 'quip':
   if not have_quippy:
      exit_error("Got energy_calculator=quip but not quippy module\n", 3)
   do_calc_quip=True
   try:
     ns_args['QUIP_pot_args'] = args.pop('QUIP_pot_args')
   except:
     exit_error("need QUIP potential args QUIP_pot_args\n",1)
   try:
     ns_args['QUIP_pot_params_file'] = args.pop('QUIP_pot_params_file')
   except:
     exit_error("need QUIP potential params file QUIP_pot_params_file\n",1)
elif ns_args['energy_calculator'] == 'lammps':
   exit_error("energy_calculator=lammps not implemented yet\n", 3)
   do_calc_lammps=True
elif ns_args['energy_calculator'] == 'internal':
   do_calc_internal=True
elif ns_args['energy_calculator'] == 'fortran':
   import fortranMCMDpy
   do_calc_fortran=True
   try:
     ns_args['FORTRAN_model'] = args.pop('FORTRAN_model')
   except:
     exit_error("need FORTRAN model FORTRAN_model\n",1)
   f_MC_MD = fortranMCMDpy.fortran_MC_MD(ns_args['FORTRAN_model'])
   f_MC_MD.init_model()
else:
   exit_error("energy_calculator=%s unknown\n" % ns_args['energy_calculator'], 3)

ns_args['no_extra_walks_at_all'] = args.pop('no_extra_walks_at_all', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]

ns_args['rng'] = args.pop('rng', 'numpy')
import ns_rng
if ns_args['rng'] == 'numpy':
   rng = ns_rng.NsRngNumpy(ns_args['delta_random_seed'],comm)
# elif ns_args['rng'] == 'julia':
#    import julia
#    j = julia.Julia()
#    rng = ns_rng.NsRngJulia(j)
elif ns_args['rng'] == 'rngstream':
   import rngstream
   rng = ns_rng.NsRngStream(ns_args['delta_random_seed'],comm)
elif ns_args['rng'] == 'internal':
   rng = ns_rng.NsRngInternal(ns_args['delta_random_seed'],comm)
else:
   exit_error("rng=%s unknown\n" % ns_args['rng'], 3)

if do_calc_fortran:
   l_seed = f_MC_MD.seed_size()
   seed = np.array( [0] * l_seed , dtype=np.int32)
   for i in range(l_seed):
      seed[i] = rng.int_uniform(1,sys.maxint)
   f_MC_MD.set_seed(seed)

movement_args={}

movement_args['atom_n_steps_expected'] = int(args.pop('atom_n_steps_expected', 0))
movement_args['atom_n_steps'] = int(args.pop('atom_n_steps', 0))
movement_args['atom_n_substeps'] = int(args.pop('atom_n_substeps', 10))
movement_args['cell_n_substeps'] = int(args.pop('cell_n_substeps', 1))
try:
   movement_args['atom_algorithm'] = args.pop('atom_algorithm')
except:
      exit_error("Failed to read algorithm for atom motion atom_algorithm", 1)
if movement_args['atom_n_steps_expected'] == 0 and movement_args['atoms_n_steps'] == 0:
   exit_error("Got both atoms_n_steps_expected and atoms_n_steps == 0\n", 3)
if movement_args['atom_algorithm'] != 'MC' and movement_args['atom_algorithm'] != 'MD':
   exit_error("Got unknown atom_algorithm '%s'\n" % movement_args['atom_algorith,'], 3)

movement_args['MC_atom_velocities'] = args.pop('MC_atom_velocities', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]
movement_args['MC_atom_step_size'] = float(args.pop('MC_atom_step_size', 0.1))
movement_args['MC_atom_step_size_max'] = float(args.pop('MC_atom_step_size_max', 1.0))
movement_args['MC_atom_velo_step_size'] = float(args.pop('MC_atom_velo_step_size', 0.1))
movement_args['MC_atom_velo_step_size_max'] = float(args.pop('MC_atom_velo_step_size_max', 1.0))
movement_args['MC_atom_uniform_rv'] = args.pop('MC_atom_uniform_rv', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]
movement_args['do_velocities'] = (movement_args['atom_algorithm'] == 'MD' or movement_args['MC_atom_velocities'])

movement_args['MD_atom_velo_perturb'] = float(args.pop('MD_atom_velo_perturb', 0.1))
movement_args['MD_atom_timestep'] = float(args.pop('MD_atom_timestep', 0.1))
movement_args['MD_atom_timestep_max'] = float(args.pop('MD_atom_timestep_max', 0.2))
movement_args['MD_atom_energy_fuzz'] = float(args.pop('MD_atom_energy_fuzz', 1.0e-2))
movement_args['MD_atom_reject_energy_violation'] = args.pop('MD_atom_reject_energy_violation', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]

movement_args['MC_cell_P'] = float(args.pop('MC_cell_P', 0.0))
movement_args['MC_cell_volume_step_size'] = float(args.pop('MC_cell_volume_step_size', 0.01))
movement_args['MC_cell_volume_step_size_max'] = float(args.pop('MC_cell_volume_step_size_max', 0.05))
movement_args['MC_cell_volume_prob'] = float(args.pop('MC_cell_volume_prob', 1.0))
movement_args['MC_cell_stretch_step_size'] = float(args.pop('MC_cell_stretch_step_size', 0.01))
movement_args['MC_cell_stretch_step_size_max'] = float(args.pop('MC_cell_stretch_step_size_max', 0.05))
movement_args['MC_cell_stretch_prob'] = float(args.pop('MC_cell_stretch_prob', 1.0))
movement_args['MC_cell_shear_step_size'] = float(args.pop('MC_cell_shear_step_size', 0.01))
movement_args['MC_cell_shear_step_size_max'] = float(args.pop('MC_cell_shear_step_size_max', 0.05))
movement_args['MC_cell_shear_prob'] = float(args.pop('MC_cell_shear_prob', 1.0))

movement_args['MC_cell_min_aspect_ratio'] = float(args.pop('MC_cell_min_aspect_ratio', 0.5))
movement_args['MC_cell_max_volume_per_atom'] = float(args.pop('MC_cell_max_volume_per_atom', 1.0e3))

movement_args['adjust_step_interval'] = int(args.pop('adjust_step_interval', -10))
movement_args['MC_adjust_step_factor'] = float(args.pop('MC_adjust_step_factor', 2.0))
movement_args['MD_adjust_step_factor'] = float(args.pop('MD_adjust_step_factor', 1.5))

movement_args['2D'] = args.pop('2D', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]

if 'QUIP_pot_params_file' in ns_args:
   if not have_quippy:
      exit_error("Got QUIP_pot_params but no quippy module\n", 3)
   try:
      if rank == 0:
	 ns_args['QUIP_pot_params'] = open(ns_args['QUIP_pot_params_file'],"r").read()
      else:
	 ns_args['QUIP_pot_params'] = None
      if comm is not None:
	 ns_args['QUIP_pot_params'] = comm.bcast(ns_args['QUIP_pot_params'], root=0)
   except:
      exit_error("Failed to read params file '%s'\n" % ns_args['QUIP_pot_params_file'], 1)
else:
   if ns_args['energy_calculator'] != 'internal' and ns_args['energy_calculator'] != 'fortran' and rank == 0:
      sys.stderr.write("Got no *_pot_params_file")

if len(args) > 0:
  exit_error(str(args)+"\nUnknown arguments read in\n", 2)

if rank == 0:
   print "ns_args ",ns_args
   print "movement_args ",movement_args

# initialise potential
if do_calc_quip:
   pot = quippy.Potential(ns_args['QUIP_pot_args'], param_str=ns_args['QUIP_pot_params'], calculation_always_required=True, cutoff_skin=1.0)
elif do_calc_internal or do_calc_fortran:
   pass
elif do_calc_lammps:
   exit_error("no lammps initialization of potential implemented yet\n", 3)
else:
   exit_error("Need some way of initializing calculator\n",3)

# figure out numbers of local walkers
rank_of_walker = [0]*ns_args['n_walkers']
if size <= 1:
   n_walkers = ns_args['n_walkers']
else:
   n_walkers_per_task = ns_args['n_walkers']/size
   if n_walkers_per_task*size != ns_args['n_walkers']:
      exit_error("number of walkers %d not divisible by number of MPI processes %d\n" % (ns_args['n_walkers'], size), 5)
   last_walker = 0
   for i_rank in range(size):
      first_walker = last_walker
      last_walker = last_walker + n_walkers_per_task
      if last_walker > ns_args['n_walkers']:
	 last_walker = ns_args['n_walkers']
      if i_rank == rank:
	 n_walkers = last_walker-first_walker
	 my_first_walker = first_walker
	 my_last_walker = last_walker
      if last_walker > first_walker:
	 rank_of_walker[first_walker:last_walker] = [i_rank]*(last_walker-first_walker)

# figure out number of configs that will be culled on each task
n_cull = ns_args['n_cull']
n_extra_walk_per_task = ns_args['n_extra_walk_per_task']
max_n_cull_per_task = int(n_cull/size)
if max_n_cull_per_task * size != n_cull:
   max_n_cull_per_task += 1

# internal model, LJ eps=1, sigma=1, cutoff=3,  with PBC cube l = pbc[0,0]
internal_cutoff = 3.0
Eshift = internal_cutoff**-12 - internal_cutoff**-6
def internal_Vlj(dr_vec, Eshift=0.0):
   return (np.sum(dr_vec**-12 - dr_vec**-6) - Eshift*len(dr_vec))

# pos is Nx3, l is a scalar box size
def energy_internal_pos(pos, l):
   n_at=np.size(pos,0)
   dr_list = np.zeros( (n_at*(n_at-1)/2,3) )
   offset=0
   # calc relative pos vector
   for i in range(n_at):
      dr_list[offset:offset+(n_at-i-1),0] = pos[i,0] - pos[i+1:,0]
      dr_list[offset:offset+(n_at-i-1),1] = pos[i,1] - pos[i+1:,1]
      dr_list[offset:offset+(n_at-i-1),2] = pos[i,2] - pos[i+1:,2]
      offset += n_at-i-1
   # apply min image
   dr_list[:,:] -= l*np.floor(dr_list[:,:]/l+0.5)
   # magnitude of vectors
   dr_list_mag = np.sqrt(np.sum(dr_list*dr_list,axis=1))

   return np.sum(internal_Vlj(dr_list_mag[np.where(dr_list_mag < internal_cutoff)],Eshift))

def energy_internal(at):
   return energy_internal_pos(at.get_positions(), at.get_cell()[0,0])

def eval_energy(at, do_PE=True, do_KE=True, do_PV=True):
   # potential
   if do_PE:
      if do_calc_quip or do_calc_lammps:
	 energy = at.get_potential_energy()
      elif do_calc_internal:
	 energy = energy_internal(at)
      elif do_calc_fortran:
	 energy = f_MC_MD.eval_energy(at)
      else:
	 sys.stderr.write("No way to eval_energy()\n", 5)
   else:
      energy = 0.0

   # kinetic
   if do_KE and at.has('momenta') and at.has('masses'):
      energy += at.get_kinetic_energy()

   if do_PV:
      energy += movement_args['MC_cell_P']*at.get_volume()

   return energy

def propagate_NVE_quippy(at, dt, n_steps):
   old_velo = at.get_velocities()
   if old_velo is not None:
      if not hasattr(at, 'velo'):
	 at.add_property('velo', 0.0, n_cols=3)
      at.velo[:,:] = old_velo.transpose()/(ase.units.Ang/ase.units.fs)
   ds=quippy.DynamicalSystem(at)


   if ns_args['debug'] >= 10:
      ds.run(pot, dt=dt/ase.units.fs, n_steps=n_steps, summary_interval=1, write_interval=0, save_interval=0)
   else:
      ds.run(pot, dt=dt/ase.units.fs, n_steps=n_steps, summary_interval=0, write_interval=0, save_interval=0)

   at.set_velocities(at.velo.transpose()*(ase.units.Ang/ase.units.fs))


def velo_rv_mag(at, Emax):
   if movement_args['2D']:
      unit_rv[:,2] = 0.0
      nDOF = 2.0
   else:
      nDOF = 3.0
   # In 3D rv_mag should have prob distrib p(r) = r^(3N-1). 
   # Using transformation rule p(y) = p(x) |dx/dy|, with p(y) = y^{3N-1} and p(x) = 1,
   #       one gets dx/dy = y^{3N-1}
   #                x = y^{3N}
   #                y = x^{1/3N}
   return rng.float_uniform(0.0,1.0)**(1.0/(nDOF*len(at)))

def velo_unit_rv(at):
   unit_rv = rng.normal( 1.0, (len(at), 3) )
   unit_rv /= np.linalg.norm(unit_rv)
   return unit_rv

def gen_random_velo(at, Emax, unit_rv=None):
   if unit_rv is None:
      unit_rv = velo_unit_rv(at)
   rv_mag = velo_rv_mag(at, Emax)

   # from Baldock thesis Eq. 11.10 
   #     p^{**} = r \mathbf{S} \hat{\mathbf{r}}
   # and 11.11 
   #     S_{ij} = \delta_{ij} (2 m_i [ E_{lim} - U(q))])^{1/2}
   # p_i = r (2 m_i)^{1/2} (E-U)^{1/2} \hat{r}_i
   # v_i = p_i / m_i = r (2/m)^{1/2} (E-U)^{1/2} \hat{r}_i

   pot_energy = eval_energy(at, do_KE=False)
   if Emax > pot_energy:
      masses = at.get_masses()
      velocities = rv_mag * np.sqrt(2.0/np.array([masses,]*3).transpose()) * np.sqrt((Emax-pot_energy)) * unit_rv
   else: # should never happen
      if rank == 0:
	 print print_prefix, ": WARNING: got pot_energy ",pot_energy, " > Emax ",Emax, " in gen_random_velo"
      velocities = 0.0 * unit_rv

   return velocities

from itertools import izip
def pairwise(iterable):
   a = iter(iterable)
   return izip(a, a)

def perturb_velo(at, Emax, rotate=True):
#DOC 
#DOC \vspace*{\baselineskip}
#DOC perturb\_velo
#DOC \begin{itemize}

   if not at.has('momenta') or not at.has('masses'):
      return

   if movement_args['MD_atom_velo_perturb'] == 0.0:
      return

   orig_KE = at.get_kinetic_energy()
   #DOC \item if MD\_atom\_velo\_perturb $<$ 0 pick random velocities consistent with Emax
   if movement_args['MD_atom_velo_perturb'] < 0.0:
      # randomize completely
      at.set_velocities(gen_random_velo(at, Emax))
   #DOC \item else perturb velocities
   #DOC \begin{itemize}
   else: # perturb
      velo = at.get_velocities()
      velo_mag = np.linalg.norm(velo)
      #DOC \item if current velocity=0, pick random velocities consistent with Emax
      if velo_mag == 0.0:
	 at.set_velocities(gen_random_velo(at, Emax))
      #DOC \item else, pick new random magnitude consistent with Emax, random rotation of current direction
      else:
	 # pick new random magnitude - count on dimensionality to make change small
	 velo = gen_random_velo(at, Emax, velo/velo_mag)

	 if rotate:
	    # apply random rotations
	    indices = range(len(at))
	    rng.shuffle_in_place(indices)
	    for (ind_1_i, ind_2_i) in pairwise(indices):
	       ind_1_j = rng.int_uniform(0,3)
	       ind_2_j = rng.int_uniform(0,3)
	       ang = rng.float_uniform(-movement_args['MD_atom_velo_perturb']*3.14159,movement_args['MD_atom_velo_perturb']*3.14159)
	       c_ang = np.cos(ang)
	       s_ang = np.sin(ang)
	       v_1 = velo[ind_1_i,ind_1_j] * c_ang + velo[ind_2_i,ind_2_j] * s_ang
	       v_2 = -velo[ind_1_i,ind_1_j] * s_ang + velo[ind_2_i,ind_2_j] * c_ang
	       velo[ind_1_i,ind_1_j] = v_1
	       velo[ind_2_i,ind_2_j] = v_2

	 at.set_velocities(velo)
   new_KE = at.get_kinetic_energy()
   # perturb_velo expects at.info['ns_energy'] to be set correctly initially
   at.info['ns_energy'] += new_KE-orig_KE
   #DOC \end{itemize}
#DOC \end{itemize}

def do_MD_atom_walk(at, movement_args, Emax):
#DOC 
#DOC \vspace*{\baselineskip}
#DOC do\_MD\_atom\_walk
#DOC \begin{itemize}

   orig_E = at.info['ns_energy']
   orig_pos = at.get_positions()
   orig_velo = at.get_velocities()

   if orig_E >= Emax:
      print print_prefix, ": WARNING: orig_E =",orig_E," >= Emax =",Emax

   #DOC \item perturb\_velo, magnitude and rotation
   perturb_velo(at, Emax)

   pre_MD_E = at.info['ns_energy']

   #DOC \item propagate in time atom\_n\_substeps time steps of length MD\_atom\_timestep
   if do_calc_quip:
      propagate_NVE_quippy(at, dt=movement_args['MD_atom_timestep'], n_steps=movement_args['atom_n_substeps']) 
      final_E = eval_energy(at)
   elif do_calc_fortran:
      final_E = f_MC_MD.MD_atom_NVE_walk(at, n_steps=movement_args['atom_n_substeps'], timestep=movement_args['MD_atom_timestep'], debug=ns_args['debug'])
      final_E += eval_energy(at,do_PE=False, do_KE=False)
   else:
      exit_error("Need some non-quippy, non-fortran way of doing MD\n",3)

   reject_fuzz = False
   KE = eval_energy(at, do_PE=False, do_PV=False)
   #DOC \item optionally accept/reject entire move on E deviating by more than energy fuzz times kinetic energy
   if abs(final_E-pre_MD_E) > movement_args['MD_atom_energy_fuzz']*KE:
      if movement_args['MD_atom_reject_energy_violation']:
	 reject_fuzz = True
      else:
	 print print_prefix, ": WARNING: MD energy deviation > fuzz*KE. Pre-MD, post-MD, difference, KE ", pre_MD_E, final_E, final_E-pre_MD_E, KE

   #DOC \item accept/reject entire move on E $<$ Emax
   reject_Emax = (final_E >= Emax)

   if reject_fuzz or reject_Emax:
      print print_prefix, ": WARNING: reject MD traj Emax ", Emax, " initial E ", orig_E, " perturbed E ", pre_MD_E, " final E ",final_E, " KE ", KE
      at.set_positions(orig_pos)
      at.set_velocities(orig_velo)
      at.info['ns_energy'] = orig_E
   else:
      at.info['ns_energy'] = final_E

   n_accept = 1
   if movement_args['MD_atom_reject_energy_violation']:
      if reject_fuzz:
	 n_accept = 0
   else:
      if reject_Emax:
	 n_accept = 0

   return {'MD_atom' : (1, n_accept) }
#DOC \end{itemize}

def do_MC_atom_walk(at, movement_args, Emax):
#DOC 
#DOC \vspace*{\baselineskip}
#DOC do\_MC\_atom\_walk
#DOC \begin{itemize}

   #DOC \item loop atom\_n\_substeps times
   #DOC \begin{itemize}
   n_steps = movement_args['atom_n_substeps']
   step_size = movement_args['MC_atom_step_size']
   step_size_velo = movement_args['MC_atom_velo_step_size']
   n_accept=0
   n_accept_velo = None

   if do_calc_fortran:
      if movement_args['MC_atom_velocities']:
	 (n_accept, n_accept_velo, final_E) = f_MC_MD.MC_atom_walk(at, n_steps, step_size, Emax-eval_energy(at, do_PE=False, do_KE=False), step_size_velo)
	 at.info['ns_energy'] = final_E + eval_energy(at, do_PE=False, do_KE=False)
      else:
	 (n_accept, final_E) = f_MC_MD.MC_atom_walk(at, n_steps, step_size, Emax-eval_energy(at, do_PE=False))
	 at.info['ns_energy'] = final_E + eval_energy(at, do_PE=False, do_KE=True)
   else:
      dz=0.0
      for i_MC_step in range(n_steps):
	 #DOC \item loop over atoms in random order
	 #DOC \begin{itemize}
	 at_list=list(range(len(at)))
	 rng.shuffle_in_place(at_list)
	 for i_at in at_list:
	    #DOC \item propose single atom move
	    if movement_args['MC_atom_uniform_rv']: 
	       dx = rng.float_uniform(-step_size,step_size)
	       dy = rng.float_uniform(-step_size,step_size)
	       if not movement_args['2D']:
		  dz = rng.float_uniform(-step_size,step_size)
	    else:
	       dx = rng.normal(step_size)
	       dy = rng.normal(step_size)
	       if not movement_args['2D']:
		  dz = rng.normal(step_size)
	    orig_energy = at.info['ns_energy']
	    orig_pos = at.get_positions()
	    new_pos = orig_pos.copy()
	    new_pos[i_at,:] += (dx, dy,dz)
	    at.set_positions(new_pos)
	    #DOC \item accept/reject on E $<$ Emax
	    energy = eval_energy(at)
	    if energy >= Emax:
	       # reject move
	       at.set_positions(orig_pos)
	       energy = orig_energy
	    else:
	       n_accept += 1
	    at.info['ns_energy'] = energy
	 #DOC \end{itemize}
      #DOC \end{itemize}

   out = {}
   if n_accept_velo is not None:
      out['MC_atom_velo'] = (n_steps*len(at), n_accept_velo)
   out['MC_atom'] = (n_steps*len(at), n_accept)
   return out
#DOC \end{itemize}


def propose_volume_step(at, step_size):
   dV = rng.normal(step_size)
   orig_V = at.get_volume()
   new_V = orig_V*(1.0+dV)
   transform = np.identity(3)*(new_V/orig_V)**(1.0/3.0)
   p_accept = min(1.0, (new_V/orig_V)**len(at))
   return (p_accept, transform)

def propose_shear_step(at, step_size):
   # pick random vector
   rnd_vec_ind = rng.int_uniform(0, 3)
   # turn other two into orthonormal pair
   other_vec_ind = range(3)
   other_vec_ind.remove(rnd_vec_ind)
   orig_cell = at.get_cell()
   v1 = orig_cell[other_vec_ind[0],:].copy()
   v2 = orig_cell[other_vec_ind[1],:].copy()
   v1 /= np.sqrt(np.dot(v1,v1))
   v2 -= v1*np.dot(v1,v2)
   v2 /= np.sqrt(np.dot(v2,v2))
   # pick random magnitudes
   rv1 = rng.normal(step_size)
   rv2 = rng.normal(step_size)
   # create new cell and transformation matrix
   new_cell = orig_cell.copy()
   new_cell[rnd_vec_ind,:] += rv1*v1 + rv2*v2
   transform = np.dot(np.linalg.inv(orig_cell), new_cell)
   return (1.0, transform)

def propose_stretch_step(at, step_size):
   rnd_v1_ind = rng.int_uniform(0, 3)
   rnd_v2_ind = rng.int_uniform(0, 3)
   if rnd_v1_ind == rnd_v2_ind:
      rnd_v2_ind = (rnd_v2_ind+1) % 3

   rv = rng.normal(step_size)
   transform = np.identity(3)
   transform[rnd_v1_ind,rnd_v1_ind] = np.exp(rv)
   transform[rnd_v2_ind,rnd_v2_ind] = np.exp(-rv)
   return (1.0, transform)

def min_aspect_ratio(vol, cell):
   min_aspect_ratio = sys.float_info.max
   for i in range(3):
      vi = cell[i,:]
      vnorm_hat = np.cross(cell[(i+1)%3,:],cell[(i+2)%3,:])
      vnorm_hat /= np.sqrt(np.dot(vnorm_hat,vnorm_hat))
      min_aspect_ratio = min(min_aspect_ratio, abs(np.dot(vnorm_hat,vi)))
   return min_aspect_ratio/(vol**(1.0/3.0))

def do_cell_step(at, Emax, p_accept, transform):
   if p_accept < 1.0 and rng.float_uniform(0.0,1.0) > p_accept:
      return False

   # save old config and apply transformation
   orig_cell = at.get_cell()
   new_cell = np.dot(orig_cell,transform)
   new_vol = abs(np.dot(new_cell[0,:],np.cross(new_cell[1,:],new_cell[2,:])))
   # check size and shape constraints
   if new_vol > movement_args['MC_cell_max_volume_per_atom']*len(at):
      return False
   if min_aspect_ratio(new_vol, new_cell) < movement_args['MC_cell_min_aspect_ratio']:
      return False

   # orig_cell already saved previous value
   orig_pos = at.get_positions()

   # set new positions and velocities
   at.set_cell(new_cell, scale_atoms=True)

   # calculate new energy
   new_energy = eval_energy(at)
   # accept or reject
   if new_energy < Emax: # accept
      at.info['ns_energy'] = new_energy
      return True
   else: # reject and revert
      at.set_cell(orig_cell,scale_atoms=False)
      at.set_positions(orig_pos)
      return False

def do_MC_cell_walk(at, movement_args, Emax):
#DOC 
#DOC \vspace*{\baselineskip}
#DOC do\_MC\_cell\_walk
#DOC \begin{itemize}
   if movement_args['MC_cell_P'] <= 0.0:
      return {}

   possible_moves = {
      'MC_cell_volume': propose_volume_step,
      'MC_cell_shear': propose_shear_step,
      'MC_cell_stretch': propose_stretch_step }

   items = possible_moves.items()
   #DOC \item loop cell\_n\_substeps times:
   #DOC \begin{itemize}
   for i in range(movement_args['cell_n_substeps']):
      rng.shuffle_in_place(items)
      out = {}
      #DOC \item do in random order
      #DOC \begin{itemize}
      for key, propose_step_func in items:
	 #DOC \item volume move if rng $<$ acceptance probablity
	 #DOC \item shear move if rng $<$ acceptance probablity
	 #DOC \item stretch move if rng < acceptance probablity
	 step_rv = rng.float_uniform(0.0, 1.0)
	 if step_rv < movement_args[key+"_prob"]:
	    (p_accept, transform) = propose_step_func(at, movement_args[key+"_step_size"])
	    if do_cell_step(at, Emax, p_accept, transform):
	       out[key] = (1, 1)
	    else:
	       out[key] = (1, 0)
      #DOC \end{itemize}
   #DOC \end{itemize}

   return out
#DOC \end{itemize}

def do_atom_walk(at, movement_args, Emax):
   if movement_args['atom_algorithm'] == 'MC':
      out = do_MC_atom_walk(at, movement_args, Emax)
   elif movement_args['atom_algorithm'] == 'MD':
      out = do_MD_atom_walk(at, movement_args, Emax)
   else:
      exit_error("do_atom_walk got unknown 'atom_algorithm' = '%s'\n" % movement_args['atom_algorithm'], 5)

   return out

def walk_single_walker(at, movement_args, Emax):
#DOC 
#DOC \vspace*{\baselineskip}
#DOC walk\_single\_walker
#DOC \begin{itemize}

   #DEBUG print "walk_single_walker start w/o PE ", eval_energy(at, do_PE=False), " w/ PE ", eval_energy(at), "Emax ", Emax #DEBUG
   possible_moves = [do_atom_walk, do_MC_cell_walk]
   out = {}

   #DOC \item loop atom\_n\_steps times
   #DOC \begin{itemize}
   for i_step in range(movement_args['atom_n_steps']):
      #DOC \item do in random order
      #DOC \begin{itemize}
      rng.shuffle_in_place(possible_moves)
      for move in possible_moves:
	 #DOC \item do\_(MC $|$ MD)\_atom\_walk
	 #DOC \item do\_MC\_cell\_walk
	 accumulate_stats(out, move(at, movement_args, Emax))
      #DOC \end{itemize}
   #DOC \end{itemize}

   #DOC \item perturb final energy of random\_energy\_perturbation
   # perturb final energy
   at.info['ns_energy'] += rng.float_uniform(-1.0,0.0)*ns_args['random_energy_perturbation']

   #DEBUG print "walk_single_walker end ", eval_energy(at, do_PE=False), eval_energy(at) #DEBUG

   return out
#DOC \end{itemize}



def max_energy(walkers, n):
   # do local max
   energies_loc = np.array([ at.info['ns_energy'] for at in walkers])
   if comm is not None:
      energies = np.zeros( (comm.size*len(energies_loc)) )
      # comm.barrier() #BARRIER
      comm.Allgather( [ energies_loc, MPI.DOUBLE ], [ energies, MPI.DOUBLE ] )
      energies = energies.flatten()
   else:
      energies = energies_loc

   Emax_ind = energies.argsort()[-1:-n-1:-1]
   Emax = energies[Emax_ind]
   # WARNING: assumes that each node has equal number of walkers
   rank_of_max = np.floor(Emax_ind/len(walkers)).astype(int)

   return (Emax, np.mod(Emax_ind,len(walkers)), rank_of_max)

def adjust_step_sizes(walk_stats, movement_args, comm):
   for key in walk_stats:
      (n_try, n_accept) = walk_stats[key]
      if comm is not None:
	 n_try_s = np.array( [n_try], dtype = np.int)
	 n_accept_s = np.array( [n_accept], dtype = np.int)
	 n_try_g = np.zeros( (1), dtype=np.int) 
	 n_accept_g = np.zeros( (1), dtype=np.int) 
	 # comm.barrier() #BARRIER
	 comm.Allreduce([n_try_s, MPI.INT], [n_try_g, MPI.INT], MPI.SUM)
	 comm.Allreduce([n_accept_s, MPI.INT], [n_accept_g, MPI.INT], MPI.SUM)
	 n_try = n_try_g[0]
	 n_accept = n_accept_g[0]

      if n_try > 0:
	 rate = float(n_accept)/float(n_try)

	 if comm.rank == 0:
	    print print_prefix, "accept rate for %s = %f (%d)" % (key, rate, n_try)

	 if key.find("MC") == 0:
	    min_rate = 0.25
	    max_rate = 0.75
	    suffix="step_size"
	 elif key.find("MD") == 0:
	    min_rate = 0.95
	    max_rate = 1.00
	    suffix="timestep"
	 else:
	    exit_error("adjust_step_size got key '%s', neither MC nor MD\n" % key, 5)

	 dir = None
	 exp = 0.0
	 if rate < min_rate:
	    exp = -1.0
	    dir = "down"
	 elif rate >= max_rate:
	    exp = 1.0
	    dir = "up"

	 orig_value = movement_args[key+"_"+suffix]

	 if dir is not None:
	    # try to adjust
	    movement_args[key+"_"+suffix] *= movement_args['MC_adjust_step_factor']**exp
	    # if exceeded maximum, cap change
	    if movement_args[key+"_"+suffix] > movement_args[key+"_"+suffix+"_max"]:
	       movement_args[key+"_"+suffix] = movement_args[key+"_"+suffix+"_max"]

	 # if was already at max and didn't really change, unset dir
	 if movement_args[key+"_"+suffix] == orig_value:
	    dir=None

	 if dir is not None and comm.rank == 0:
	    print print_prefix, "adjust_step_sizes adjusted %s %s to %f" % (key, dir, movement_args[key+"_"+suffix])

def zero_stats(d, movement_args):
   for key in movement_args:
      m = re.search('(.*)_(step_size|timestep)$', key)
      if m is not None:
        d[m.group(1)] = (0, 0)

def accumulate_stats(d_cumul, d):
   for key in d:
      if key in d_cumul:
	 d_cumul[key] = tuple([i1+i2 for i1,i2 in zip(d[key],d_cumul[key])])
      else:
	 d_cumul[key] = d[key]


# figure out n_steps to walk on each iteration to get correct expected number
def set_n_steps(prop):
   if movement_args[prop+'_expected'] > 0:
      if movement_args[prop] > 0:
	 exit_error("Got both "+prop+" and "+prop+"_expected, conflict\n", 5)

      if max_n_cull_per_task*size == n_cull and n_extra_walk_per_task == 0: # no extra walkers
	 movement_args[prop] = movement_args[prop+'_expected']
	 if rank == 0:
	    print "Calculating n_walks, trivial since there are no extra walkers"
      else:
	 # f_c = n_c/n_t [ fraction of total that are culled (and walked once)]
	 # f_e = n_e/(n_t-n_c) [fraction of ones that aren't culled that are also walked ]

	 # n(1) <- f_c n_t + (1-f_c)*(1-f_e) n(1)
	 # n(l >= 2) <- (1-f_c)(1-f_e) n(l) + (1-f_c) f_e n(l-1)

	 # f = (1-f_c)f_e / (f_c+f_e-f_c f_e)

	 # n(1)/n_t = f_c/(1-(1-f_c)(1-f_e)) = f_c/(f_c+f_e-f_c f_e)
	 # n(l >= 2)/n_t = f n(l-1) = f^(l-1) n(1)/n_t
	 # n_walks = n(1)/n_t + sum_{l=2}^\infty l n(l)/n_t
	 #         = n(1)/n_t (1 + sum_{l=2}^\infty l f^{l-1})
	 #         = n(1)/n_t (1 + \sum{l=1}^\infty (l+1) f^l)
	 #         = n(1)/n_t (1 + \sum f^l + sum l f^l)
	 #         = n(1)/n_t (1 + f/(1-f) + f/(1-f)**2

	 f_cull = float(n_cull)/float(ns_args['n_walkers'])
	 f_extra = float( (max_n_cull_per_task*size-n_cull) + n_extra_walk_per_task*size ) / float(ns_args['n_walkers']-n_cull)
	 f = (1.0-f_cull)*f_extra/(f_cull+f_extra-f_cull*f_extra)

	 n_walks = f_cull/(f_cull+f_extra-f_cull*f_extra) * (1.0 + f/(1.0-f) + f/(1.0-f)**2)
	 if rank == 0:
	    print "Calculated n_walks =",n_walks, " from f_cull ",f_cull," f_extra ",f_extra
	 movement_args[prop] = int(math.ceil(movement_args[prop+'_expected']/n_walks))
	 
   else:
      if movement_args[prop] > 0 and rank == 0:
	 print "WARNING: using absolute number of "+prop

def init_config(at, Emax):
   pos = at.get_positions()
   for i_at in range(1,len(at)):
      at_new = at[0:i_at+1]
      at_new.set_positions(pos[0:i_at+1,:])
      success = False
      for i_try in range(10):
	 pos[i_at,:] = np.dot(at_new.get_cell(), rng.float_uniform(0.0, 1.0, (3) ))
	 at_new.set_positions(pos[0:i_at+1,:])
	 energy = eval_energy(at_new)
	 if energy < Emax:
	    success = True
	    break
      if not success:
	 exit_error("Failed 10 times to insert atom %d with Emax %f" % (i_at, Emax), 7)
   at.set_positions(pos)
   return energy

set_n_steps('atom_n_steps')
if  rank == 0:
   print "Using atom_n_steps = ", movement_args['atom_n_steps']

walkers=[]
if ns_args['restart_file'] == '': # start from scratch
   # create initial config
   if rank == 0:
      # create atoms structs from a list of atomic numbers and numbers of atoms
      lc = ns_args['start_volume_per_atom']**(1.0/3.0)
      init_atoms = ase.Atoms(cell=(lc, lc, lc), pbc=(1,1,1))
      species = ns_args['start_species'].split(',')
      for specie in species:
	 specie_fields = specie.split()
	 type_Z = int(specie_fields[0])
	 type_n = int(specie_fields[1])
	 if len(specie_fields) == 2:
	    init_atoms += ase.Atoms([type_Z] * type_n)
	 elif len(specie_fields) == 3:
	    type_mass = float(specie_fields[2])
	    init_atoms += ase.Atoms([type_Z] * type_n, masses=[type_mass] * type_n)
	 else:
	    exit_error("Each entry is start_species must include atomic number, multiplicity, and optionally mass", 5)
      init_atoms.set_cell(init_atoms.get_cell()*float(len(init_atoms))**(1.0/3.0), scale_atoms=True)
      if have_quippy:
	 init_atoms = quippy.Atoms(init_atoms)
      ase.io.write(sys.stdout, init_atoms, format="extxyz")
   else:
      init_atoms = None

   if comm is not None:
      init_atoms = comm.bcast(init_atoms, root=0)
   if do_calc_quip:
      init_atoms.set_cutoff(pot.cutoff(), cutoff_skin=1.0)

   # make sure masses are set if MD is going to be used
   if movement_args['do_velocities'] and not init_atoms.has('masses'):
      if have_quippy:
	 if not hasattr(init_atoms,'mass'):
	    init_atoms.add_property('mass', 0.0)
	    init_atoms.mass[:] = quippy.ElementMass[init_atoms.Z]
	 init_atoms.set_masses(init_atoms.mass/quippy.MASSCONVERT)
      else:
	 exit_error("MD set, but masses weren't specified in start_species, and quippy is not available for automatically setting masses\n", 3)

   # clone initial config into array of walkers
   for i_walker in range(n_walkers):
     walkers.append(init_atoms.copy())
   ns_args['restart_first_iter'] = 0

   for at in walkers:
      at.set_velocities(np.zeros( (len(walkers[0]), 3) ))
      if do_calc_quip or do_calc_lammps:
	 at.set_calculator(pot)

   ns_args['start_energy_ceiling'] += movement_args['MC_cell_P']*init_atoms.get_volume()
   # initial positions are just random, up to an energy ceiling
   for at in walkers:
      at.set_scaled_positions( rng.float_uniform(0.0, 1.0, (len(at), 3) ) )
      if do_calc_fortran:
	 f_MC_MD.init_config(at, ns_args['start_energy_ceiling'])
      energy = eval_energy(at)
      n_try = 0
      while math.isnan(energy) or energy > ns_args['start_energy_ceiling']:
	 if n_try > 10:
	    exit_error("Failed to generate initial config under max energy %f in 10 tries\n" % ns_args['start_energy_ceiling'], 4)
	 energy = init_config(at, ns_args['start_energy_ceiling'])
	 n_try += 1
      at.info['ns_energy'] = energy + rng.float_uniform(-1.0,0.0)*ns_args['random_energy_perturbation']

      # set initial velocities, rejection free
      if movement_args['do_velocities']:
	 perturb_velo(at, ns_args['start_energy_ceiling'])

else: # doing a restart
   if rank == 0: # read on head task and send to other tasks
      i_at = 0
      for r in range(size):
	 at_list=[]
	 for i_walker in range(n_walkers):
	    print "read i_at ",i_at, " from ",ns_args['restart_file']
	    if comm is None or r == 0:
	       walkers.append(ase.io.read(ns_args['restart_file'], i_at))
	    else:
	       at_list.append(ase.io.read(ns_args['restart_file'], i_at))
	    i_at += 1
	 if r > 0:
	    comm.send(at_list, dest=r, tag=1)
   else: # receive from head task
      walkers = comm.recv(source=0, tag=1)

   for at in walkers:
      if do_calc_quip or do_calc_lammps:
	 at.set_calculator(pot)
      at.info['ns_energy'] = eval_energy(at) + rng.float_uniform(-1.0,0.0)*ns_args['random_energy_perturbation']

def save_snapshot(id):
   #QUIP_IO if have_quippy:
      #QUIP_IO snapshot_io = quippy.CInOutput(ns_args['out_file_prefix']+'snapshot.%s.%d.xyz' % (id,rank), action=quippy.OUTPUT)
   #QUIP_IO else:
      #QUIP_IO try:
	 #QUIP_IO snapshot_file=ns_args['out_file_prefix']+'snapshot.'+('%d' % id)+'.%05d.'+('%04d' % rank)+'.extxyz'
      #QUIP_IO except:
	 #QUIP_IO snapshot_file=ns_args['out_file_prefix']+'snapshot.'+id+'.%05d.'+('%04d' % rank)+'.extxyz'
   try:
      snapshot_io = open(ns_args['out_file_prefix']+'snapshot.%s.%d.extxyz' % (id,rank), "w")
   except:
      snapshot_io = open(ns_args['out_file_prefix']+'snapshot.%d.%d.extxyz' % (id,rank), "w")

   i_at = 0
   for at in walkers:
      #QUIP_IO if have_quippy:
	 #QUIP_IO at.write(snapshot_io)
      #QUIP_IO else:
	 #QUIP_IO ase.io.write(snapshot_file % i_at, ase.Atoms(at))
      ase.io.write(snapshot_io, at, format='extxyz')
      i_at += 1

   snapshot_io.close()

def clean_prev_snapshot(prev_snapshot_iter):
   if prev_snapshot_iter is not None:
      snapshot_file=ns_args['out_file_prefix']+'snapshot.%d.%d.extxyz' % (prev_snapshot_iter, rank)
      try:
	 os.remove(snapshot_file)
      except:
	 print print_prefix, ": WARNING: Failed to delete '%s'" % snapshot_file

n_atoms = len(walkers[0])
prev_snapshot_iter = None
# do NS
def do_ns_loop():
   global print_prefix

   if rank == 0:
      nD = 3
      if movement_args['2D']:
	 nD = 2
      if ns_args['restart_file'] == '':
	 if movement_args['do_velocities']:
	    nExtraDOF = 0
	 else:
	    nExtraDOF = n_atoms*nD
	 energy_io.write("%d %d %d\n" % (ns_args['n_walkers'], ns_args['n_cull'], nExtraDOF) )

   ## print print_prefix, ": random state ", np.random.get_state()
   ## if rank == 0:
      ## print print_prefix, ": common random state ", common_random_state

   if ns_args['debug'] >= 10 and size <= 1:
      n_walks_history = []


   for at in walkers:
      print rank, ": initial energy ", at.info['ns_energy']

   walk_stats_cumul={}
   zero_stats(walk_stats_cumul, movement_args)

   initial_time = time.time()
   prev_time = initial_time

   Emax_of_step = None

   verbose=False
   for i_ns_step in range(ns_args['restart_first_iter'], ns_args['n_iter']):
      print_prefix="%d %d" % (rank, i_ns_step)

      if movement_args['adjust_step_interval'] < 0:
	 zero_stats(walk_stats_cumul, movement_args)

      if ns_args['debug'] >= 20:
	 print print_prefix, ": LOOP_TE START 00 ",i_ns_step, [ eval_energy(at) for at in walkers ]
	 print print_prefix, ": LOOP_PE START 01 ",i_ns_step, [ eval_energy(at, do_KE=False) for at in walkers ]

      # get list of highest energy configs
      (Emax, cull_ind, cull_rank) = max_energy(walkers, n_cull)
      Emax_next = Emax[-1]
      if rank == 0 and Emax_of_step is not None and Emax[0] > Emax_of_step:
	 print print_prefix, ": WARNING: energy above Emax ", Emax_of_step, " bad energies: ", Emax[np.where(Emax > Emax_of_step)], cull_rank[np.where(Emax > Emax_of_step)], cull_ind[np.where(Emax > Emax_of_step)]
	 # comm.barrier()
	 # exit_error("Energy above Emax\n", 5)

      if rank == 0 and (i_ns_step > ns_args['restart_first_iter'] and Emax_next >= Emax_of_step):
	 print "WARNING: Emax not decreasing ",Emax_of_step, Emax_next
      Emax_of_step=Emax_next

      if ns_args['min_Emax'] is not None and Emax_of_step < ns_args['min_Emax']:
	 if rank == 0:
	    print "Leaving loop because Emax=",Emax_of_step," < min_Emax =",ns_args['min_Emax']
	 break

      if rank == 0:
	 cur_time=time.time()
	 if (cur_time > prev_time+60 or i_ns_step == 0 or i_ns_step == ns_args['n_iter'] or (ns_args['n_iter'] > 0 and i_ns_step % max(int(ns_args['n_iter']/1000),1) == 0)):
	    print i_ns_step, "Emax_of_step ", Emax_of_step, cur_time-prev_time
	    prev_time = cur_time

      cull_list=[None] * size
      for r in range(size):
	 entries_for_this_rank = np.where(cull_rank == r)[0]
	 cull_list[r] = cull_ind[entries_for_this_rank]

      # record Emax walkers energies and configurations
      if rank == 0:
	 for E in Emax:
	    energy_io.write("%d %.60f\n" % (i_ns_step, E))
	 energy_io.flush()
      if cull_list[rank] is not None:
	 for i in cull_list[rank]:
	    walkers[i].info['volume'] = walkers[i].get_volume()
	    walkers[i].info['ns_P'] = movement_args['MC_cell_P']
	    if walkers[i].has('masses') and walkers[i].has('momenta'):
	       walkers[i].info['ns_KE'] = walkers[i].get_kinetic_energy()
	    #QUIP_IO if have_quippy:
	       #QUIP_IO walkers[i].write(traj_io)
	    #QUIP_IO else:
	       #QUIP_IO ase.io.write(traj_file % i_ns_step, ase.Atoms(walkers[i]))
	    ase.io.write(traj_io, walkers[i], format='extxyz')

      # calculate how many will be culled on each rank
      n_cull_of_rank = np.array([ sum(cull_rank == r) for r in range(size) ])

      # label configs to be culled
      status = np.empty( (size, n_walkers), np.object_)
      status[:,:] = ''
      for r in range(size):
	 status[r,cull_ind[np.where(cull_rank == r)[0]]] = 'c_t'

      if ns_args['debug'] >= 10:
	 initial_PE_loc = [ eval_energy(at, do_KE=False) for at in walkers ]
	 initial_PE = np.array(comm.allgather(initial_PE_loc)).flatten()
	 initial_changed = initial_PE[np.where(status.flatten() == 'c_t')]
	 initial_unchanged = initial_PE[np.where(status.flatten() == '')]

      if ns_args['debug'] >= 30:
	 for r in range(len(status)):
	    print print_prefix, ": initial status ", r, [ s for s in status[r,:] ]

      # find load balance by cloning on top of excess maxima
      recv_ind=[]
      recv_rank=[]
      send_ind=[]
      send_rank=[]
      cull_inds_to_remove=[]

      if n_cull > 1:
	 # CHECK FOR RANDOMNESS ISSUES AND WHICH NODES ARE USED FOR CLONES
	 for r in range(size):
	    # maybe remote_r should be chosen completely randomly, rather than close to task of extra culled configs
	    for dr in np.array(zip(np.array(range(1,size)), -np.array(range(1,size)))).flatten():
	       if n_cull_of_rank[r] <= max_n_cull_per_task: # not too many that need to be culled on this rank
		  break
	       # this rank has too many to cull, must receive replacement from another node
	       remote_r = (r+dr) % size
	       if n_cull_of_rank[remote_r] < max_n_cull_per_task: # send from r+dr to r
		  n_transfer = min(n_cull_of_rank[r]-max_n_cull_per_task, max_n_cull_per_task-n_cull_of_rank[remote_r])
		  recv_rank.extend([r]*n_transfer)
		  send_rank.extend([remote_r]*n_transfer)
		  local_ind = np.where(status[r,:] == 'c_t')[0][0:n_transfer]
		  recv_ind.extend(local_ind)
		  remote_ind = np.where(status[remote_r,:] == '')[0][0:n_transfer]
		  send_ind.extend(remote_ind)
		  status[r,local_ind] = 'c_s'
		  status[remote_r,remote_ind] = 'c_t_a'
		  n_cull_of_rank[r] -= n_transfer
		  n_cull_of_rank[remote_r] += n_transfer


      # save local random state, and switch to common one
      rng.switch_to_common()

      # select clones
      for r in range(size):
	 list_clone_target = np.where(status[r,:] == 'c_t')[0]
	 # assign clones
	 n_remaining_clones = len(list_clone_target)
	 while n_remaining_clones > 0:
	    remote_r = rng.int_uniform(0,size)
	    n_avail_remote = sum(status[remote_r,:] == '')
	    if n_avail_remote > 0: # something is available on remote_r
	       # send from random avail walker on remote_r to clone_target on r
	       n_transfer = min(n_remaining_clones, n_avail_remote)


	       # set ranks
	       send_rank.extend([remote_r]*n_transfer)
	       recv_rank.extend([r]*n_transfer)

	       # set indices
	       r_is = []
	       for ii in range(n_transfer):
		  r_i = rng.int_uniform(0, n_walkers)
		  while status[remote_r,r_i] != '':
		     r_i = rng.int_uniform(0, n_walkers)
		  # now r_i should be something with status ''
		  status[remote_r,r_i] = 'c_s'
		  r_is.append(r_i)
	       send_ind.extend(r_is)

	       status[r,list_clone_target[0:n_transfer]] = 'c_t_a'
	       recv_ind.extend(list_clone_target[0:n_transfer])

	       n_remaining_clones -= n_transfer

      if ns_args['debug'] >= 20:
	 print print_prefix, ": LOOP_PE POST_LOC_CLONE 15 ",i_ns_step, [ eval_energy(at, do_KE=False) for at in walkers ]

      # make into numpy arrays so that mathematical operations will work
      send_rank = np.array(send_rank)
      send_ind = np.array(send_ind)
      recv_rank = np.array(recv_rank)
      recv_ind = np.array(recv_ind)

      # save new common state, and restore to local state
      rng.switch_to_local()

      if n_cull == 1:
	 if send_rank[0] == recv_rank[0] and send_rank[0] == rank:
	    walkers[recv_ind[0]].set_positions(walkers[send_ind[0]].get_positions())
	    walkers[recv_ind[0]].set_cell(walkers[send_ind[0]].get_cell())
	    if movement_args['do_velocities']:
	       walkers[recv_ind[0]].set_velocities(walkers[send_ind[0]].get_velocities())
	    walkers[recv_ind[0]].info['ns_energy'] = eval_energy(walkers[recv_ind[0]])
	 else:
	    n_send = n_atoms + 3
	    if movement_args['do_velocities']:
	       n_send += n_atoms
	    buf = np.zeros ( (n_send, 3) )
	    if send_rank[0] == rank: # only one config is sent/received
	       buf[0:n_atoms,:] = walkers[send_ind[0]].get_positions()
	       buf[n_atoms:n_atoms+3,:] = walkers[send_ind[0]].get_cell()
	       if movement_args['do_velocities']:
		  buf[n_atoms+3:,:] = walkers[send_ind[0]].get_velocities()
	       comm.Send([buf,  MPI.DOUBLE], dest=recv_rank[0], tag=100)
	    elif recv_rank[0] == rank:
	       comm.Recv([buf, MPI.DOUBLE], source=send_rank[0], tag=100)
	       walkers[recv_ind[0]].set_positions(buf[0:n_atoms,:])
	       walkers[recv_ind[0]].set_cell(buf[n_atoms:n_atoms+3,:])
	       if movement_args['do_velocities']:
		  walkers[recv_ind[0]].set_velocities(buf[n_atoms+3:,:])
	       walkers[recv_ind[0]].info['ns_energy'] = eval_energy(walkers[recv_ind[0]])
      else: # should switch to comm.Alltoall, faster, but more manual massaging of data structures
	 # create sending/receiving buffers
	 # create sending/receiving buffers
	 pos_send_buf=[None] * size
	 vel_send_buf=[None] * size
	 cell_send_buf=[None] * size
	 for i in np.where(send_rank == rank)[0]:
	    r_recv = recv_rank[i]
	    i_send = send_ind[i]
	    if pos_send_buf[r_recv] is None:
	       pos_send_buf[r_recv] = []
	    if vel_send_buf[r_recv] is None:
	       vel_send_buf[r_recv] = []
	    if cell_send_buf[r_recv] is None:
	       cell_send_buf[r_recv] = []
	    pos_send_buf[r_recv].append(walkers[i_send].get_positions())
	    vel_send_buf[r_recv].append(walkers[i_send].get_velocities())
	    cell_send_buf[r_recv].append(walkers[i_send].get_cell())


	 # do communication
	 if comm is not None:
	    pos_recv_buf = comm.alltoall(pos_send_buf)
	    vel_recv_buf = comm.alltoall(vel_send_buf)
	    cell_recv_buf = comm.alltoall(cell_send_buf)
	 else:
	    pos_recv_buf = pos_send_buf
	    vel_recv_buf = vel_send_buf
	    cell_recv_buf = cell_send_buf

	 # copy from receive buffers into walkers structure
	 my_recv_ind = np.array(recv_ind)[np.where(np.array(recv_rank) == rank)[0]]
	 recv_i = 0
	 for (pos_array, vel_array, cell_array) in zip(pos_recv_buf, vel_recv_buf, cell_recv_buf):
	    if pos_array is not None:
	       for (pos_entry, vel_entry, cell_entry) in zip(pos_array, vel_array, cell_array):
		  walkers[my_recv_ind[recv_i]].set_positions(pos_entry)
		  walkers[my_recv_ind[recv_i]].set_velocities(vel_entry)
		  walkers[my_recv_ind[recv_i]].set_cell(cell_entry)
		  walkers[my_recv_ind[recv_i]].info['ns_energy'] = eval_energy(walkers[my_recv_ind[recv_i]])
		  recv_i += 1

      if ns_args['debug'] >= 20:
	 print print_prefix, ": LOOP_PE POST_CLONE 20 ",i_ns_step, [ eval_energy(at, do_KE=False) for at in walkers ]

      # move cloned walkers

      # walk clone targets
      if ns_args['debug'] >= 5:
	 for i in np.where(status[rank,:] == 'c_s')[0]:
	    print print_prefix, "clone source ", rank, i
      clone_walk_ind = np.where(status[rank,:] == 'c_t_a')[0]
      for i_at in clone_walk_ind:
	 if ns_args['debug'] >= 5:
	    print print_prefix, "WALK clone_target ", rank, i_at
	 walk_stats = walk_single_walker(walkers[i_at], movement_args, Emax_of_step)
	 accumulate_stats(walk_stats_cumul, walk_stats)

      # check that everything that should have been changed has, and things that shouldn't have, haven't
      if ns_args['debug'] >= 10:
	 final_PE_loc = [ eval_energy(at, do_KE=False) for at in walkers ]
	 final_PE = np.array(comm.allgather(final_PE_loc)).flatten()
	 if rank == 0:
	    final_status = status.flatten()
	    for e in initial_unchanged:
	       if e not in final_PE:
		  print "initial_PE ", initial_PE
		  print "final_PE ", final_PE
		  print "final_status ", final_status
		  print "WARNING: energy that should have been unchanged ", e," missing from final energies"
	    for e in initial_changed:
	       if e in final_PE:
		  print "initial_PE ", initial_PE
		  print "final_PE ", final_PE
		  print "final_status ", final_status
		  print "WARNING: energy that should have been changed ", e," still there in final energies"


      # walk extras
      if not ns_args['no_extra_walks_at_all']:
	 for ii in range(max_n_cull_per_task - len(clone_walk_ind)+n_extra_walk_per_task):
	    r_i = rng.int_uniform(0, n_walkers)
	    while status[rank,r_i] != '' and status[rank,r_i] != 'c_s':
	       r_i = rng.int_uniform(0, n_walkers)
	    if ns_args['debug'] >= 5:
	       print print_prefix, "WALK extra ",rank, r_i
	    walk_stats = walk_single_walker(walkers[r_i], movement_args, Emax_of_step)
	    accumulate_stats(walk_stats_cumul, walk_stats)

      if movement_args['adjust_step_interval'] != 0 and i_ns_step % abs(movement_args['adjust_step_interval']) == abs(movement_args['adjust_step_interval'])-1:
	 adjust_step_sizes(walk_stats_cumul, movement_args, comm)
	 zero_stats(walk_stats_cumul, movement_args)

      if ns_args['debug'] >= 20:
	 print print_prefix, ": LOOP_PE END 30 ",i_ns_step, [ eval_energy(at,do_KE=False) for at in walkers ]
	 print print_prefix, ": LOOP_TE END 31 ",i_ns_step, [ eval_energy(at) for at in walkers ]

      if ns_args['debug'] >= 30:
	 for r in range(len(status)):
	    print print_prefix, ": final status ", r, [ s for s in status[r,:] ]

      if ns_args['snapshot_interval'] > 0 and i_ns_step % ns_args['snapshot_interval'] == ns_args['snapshot_interval']-1:
	 global prev_snapshot_iter
	 save_snapshot(i_ns_step)
	 clean_prev_snapshot(prev_snapshot_iter)
	 prev_snapshot_iter = i_ns_step
   cur_time = time.time()
   print "LOOP TIME total ",cur_time-initial_time, " per iter ", (cur_time-initial_time)/(i_ns_step+1)

#QUIP_IO if have_quippy:
   #QUIP_IO traj_io = quippy.CInOutput(ns_args['out_file_prefix']+'traj.%d.xyz' % rank, action=quippy.OUTPUT)
#QUIP_IO else:
   #QUIP_IO traj_file = ns_args['out_file_prefix']+'traj.%08d.'+('%04d' % rank)+'.extxyz'
traj_io = open(ns_args['out_file_prefix']+'traj.%d.xyz' % rank, "w")

if rank == 0:
   energy_io = open(ns_args['out_file_prefix']+'energies', 'w')

if ns_args['profile'] == rank:
   import cProfile
   cProfile.run('do_ns_loop()','ns_run.stats')
else:
   do_ns_loop()

# cleanup post loop
save_snapshot("final")
clean_prev_snapshot(prev_snapshot_iter)

for at in walkers:
   print rank, ": final energy ", at.info['ns_energy']

if rank == 0:
   energy_io.close()
traj_io.close()

if comm is not None:
   MPI.Finalize()
sys.exit(0)
