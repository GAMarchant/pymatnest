#!/usr/bin/env python

import sys

if len(sys.argv) != 1:
  sys.stderr.write("Usage: %s < input\n" % sys.argv[0])
  sys.stderr.write("input:\n")
  sys.stderr.write("start_file=start_file.xyz (MANDATORY)\n")
  sys.stderr.write("n_walkers=n_walkers (MANDATORY)\n")
  sys.stderr.write("n_cull=n_cull (MANDATORY)\n")
  sys.stderr.write("n_steps=n_steps (MANDATORY)\n")

  sys.stderr.write("QUIP_pot_args=QUIP_pot_args (MANDATORY)\n")
  sys.stderr.write("QUIP_pot_params_file=QUIP_pot_params_file (MANDATORY)\n")

  sys.stderr.write("MC_atom_n_steps=MC_atom_n_steps\n")
  sys.stderr.write("MC_atom_step_size=MC_atom_step_size\n")
  sys.stderr.write("MD_atom_n_steps=MD_atom_n_steps\n")
  sys.stderr.write("MD_atom_timestep=MD_atom_timestep\n")
  sys.stderr.write("MD_atom_energy_fuzz=MD_atom_energy_fuzz\n")

  sys.stderr.write("2D=[ T | F ]\n")

import re, numpy as np
import ase
try:
   import quippy
   have_quippy=True
except:
   have_quippy=False

try:
   from mpi4py import MPI
   comm = MPI.COMM_WORLD
   rank = comm.Get_rank()
   size = comm.Get_size()
except:
   comm = None
   rank = 0
   size = 1

if comm is not None and rank == 0:
   print "comm ", comm, " size ", size

# read inputs
if size > 0 and rank == 0:
   infile=open("inputs","r")
else:
   infile=sys.stdin
args={}
if rank == 0:
   for line in infile:
     if re.match("\s*(#.*)?$", line):
       continue
     matches = re.match("\s*(\S+)\s*=\s*(.*\S)", line)
     args[matches.group(1)] = matches.group(2)
if comm is not None:
   args = comm.bcast(args,root=0)

# parse args

def exit_error(message, stat):
   sys.stderr.write(message)
   try:
      comm.Abort(stat)
   except:
      pass
   sys.exit(stat)

# convert from strings to actual args
ns_args={}
try:
  ns_args['start_file'] = args.pop('start_file')
except:
  exit_error("need starting position file start_file\n",1)
try:
  ns_args['n_walkers'] = int(args.pop('n_walkers'))
except:
  exit_error("need number of walkers n_walkers\n",1)
try:
  ns_args['n_cull'] = int(args.pop('n_cull'))
except:
  exit_error("need number to cull n_cull\n",1)
try:
  ns_args['n_steps'] = int(args.pop('n_steps'))
except:
  exit_error("need number of steps n_steps\n",1)
try:
  ns_args['QUIP_pot_args'] = args.pop('QUIP_pot_args')
except:
  exit_error("need QUIP potential args QUIP_pot_args\n",1)
try:
  ns_args['QUIP_pot_params_file'] = args.pop('QUIP_pot_params_file')
except:
  exit_error("need QUIP potential params file QUIP_pot_params_file\n",1)

movement_args={}
movement_args['MC_atom_n_steps'] = int(args.pop('MC_atom_n_steps', 0))
movement_args['MC_atom_step_size'] = float(args.pop('MC_atom_step_size', 0.0))
movement_args['MD_atom_n_steps'] = int(args.pop('MD_atom_n_steps', 0))
movement_args['MD_atom_timestep'] = float(args.pop('MD_atom_timestep', 0.0))
movement_args['MD_atom_energy_fuzz'] = float(args.pop('MD_atom_energy_fuzz', 1.0e-12))
movement_args['2D'] = args.pop('2D', "F") in [ "t", "T", "true", "True", "TRUE", "1" ]

confining_pot_args={}
confining_pot_args['mag'] = float(args.pop('confining_potential_mag', 0.0))

if 'QUIP_pot_params_file' in ns_args:
   if not have_quippy:
     exit_error("Got QUIP_pot_params but no quippy module\n", 3)
   try:
      if rank == 0:
	 ns_args['QUIP_pot_params'] = open(ns_args['QUIP_pot_params_file'],"r").read()
      else:
	 ns_args['QUIP_pot_params'] = None
      if comm is not None:
	 ns_args['QUIP_pot_params'] = comm.bcast(ns_args['QUIP_pot_params'], root=0)
   except:
      exit_error("Failed to read params file '%s'\n" % ns_args['QUIP_pot_params_file'], 1)
else:
   sys.stderr.write("Got no *_pot_params_file")

if len(args) > 0:
  exit_error(args+"\nUnknown arguments read in\n", 2)

if rank == 0:
   print "ns_args ",ns_args
   print "movement_args ",movement_args

# initialise potential
if have_quippy:
   pot = quippy.Potential(ns_args['QUIP_pot_args'], param_str=ns_args['QUIP_pot_params'], calculation_always_required=True)
else:
   exit_error("Need some non-quippy way of initializing calculator\n",3)

# read initial config
if have_quippy:
   init_atoms = None
   if rank == 0:
      init_atoms = quippy.Atoms(ns_args['start_file'])
   if comm is not None:
      init_atoms = comm.bcast(init_atoms, root=0)
   init_atoms.set_cutoff(pot.cutoff(), cutoff_skin=1.0)
else:
   exit_error("need some non-quippy way of reading input configuration\n",3)

# clone initial config into array of walkers
walkers=[]
rank_of_walker = [0]*ns_args['n_walkers']
if size <= 1:
   n_walkers = ns_args['n_walkers']
else:
   n_walkers_per_task = ns_args['n_walkers']/size
   if n_walkers_per_task*size != ns_args['n_walkers']:
      exit_error("number of walkers %d not divisible by number of MPI processes %d\n" % (ns_args['n_walkers'], size), 5)
   last_walker = 0
   for i_rank in range(size):
      first_walker = last_walker
      last_walker = last_walker + n_walkers_per_task
      if last_walker > ns_args['n_walkers']:
	 last_walker = ns_args['n_walkers']
      if i_rank == rank:
	 n_walkers = last_walker-first_walker
	 my_first_walker = first_walker
	 my_last_walker = last_walker
      if last_walker > first_walker:
	 rank_of_walker[first_walker:last_walker] = [i_rank]*(last_walker-first_walker)
for i_walker in range(n_walkers):
  walkers.append(init_atoms.copy())
for at in walkers:
   at.set_calculator(pot)

n_cull = ns_args['n_cull']

def eval_energy(at):
  # potential
  if have_quippy:
     energy = at.get_potential_energy()
  else:
     sys.stderr.write("Need some non-quippy way to do eval_energy")

  # confining
  if confining_pot_args['mag'] > 0.0:
     energy += confining_pot_args['mag']*(np.linalg.norm(at.pos)**2)

  # kinetic
  velocities = at.get_velocities()
  masses = at.get_masses()
  if velocities is not None and masses is not None:
      energy += at.get_kinetic_energy()

  return energy

def quippy_propagate(at, dt, n_steps):
   old_velo = at.get_velocities()
   if old_velo is not None:
      if not hasattr(at, 'velo'):
	 at.add_property('velo', 0.0, n_cols=3)
      at.velo[:,:] = old_velo.transpose()/(ase.units.Ang/ase.units.fs)
   ds=quippy.DynamicalSystem(at)
   ds.run(pot, dt=dt/ase.units.fs, n_steps=n_steps, summary_interval=0, connect_interval=1, write_interval=0, save_interval=0)
   at.set_velocities(at.velo.transpose()*(ase.units.Ang/ase.units.fs))

def do_MD_atom_walk(at, movement_args, Emax):

   print rank, ": initial positions ", at.get_positions()[0]
   if at.get_velocities() is not None:
      print rank, ": initial velo ", at.get_velocities()[0]
   else:
      print rank, ": initial velo ", None
   print rank, ": initial energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy()

   old_pos = at.get_positions()
   old_velo = at.get_velocities()

   ## print "velo ", at.get_velocities()
   masses = at.get_masses()
   ## print "masses ", masses
   unit_rv = np.random.standard_normal( (len(at), 3) )
   unit_rv /= np.linalg.norm(unit_rv)
   ## print "unit_rv ", unit_rv
   ## print "unit_rv norm ", np.linalg.norm(unit_rv)
   mag_rv = np.random.uniform()**(1.0/(3.0*len(at)-1.0))
   pot_energy = at.get_potential_energy()
   ## print "mag_rv ", mag_rv
   ## print "dup masses ", np.array([masses,]*3).transpose()
   # from Baldock thesis Eq. 11.10 
   #     p^{**} = r \mathbf{S} \hat{\mathbf{r}}
   # and 11.11 
   #     S_{ij} = \delta_{ij} (2 m_i [ E_{lim} - U(q))])^{1/2}
   # p_i = r (2 m_i)^{1/2} (E-U)^{1/2} \hat{r}_i
   # v_i = p_i / m_i = r (2/m)^{1/2} (E-U)^{1/2} \hat{r}_i
   ## print "pot_energy, Emax (eV) ", pot_energy, Emax
   ## print "pot energy (amu A^2/fs^2) ", pot_energy*eV_to_amu_A_sq_per_fs_sq
   ## print "max_KE (eV) ", Emax-pot_energy
   velocities = mag_rv * np.sqrt(2.0/np.array([masses,]*3).transpose()) * np.sqrt((Emax-pot_energy)) * unit_rv
   at.set_velocities(velocities)

   ## print "vel norms ",np.linalg.norm(at.get_velocities(), axis=1)
   print rank, ": masses for KE ",masses
   print rank, ": velocities for KE ",at.get_velocities()
   print rank, ": KE ",at.get_kinetic_energy()
   print rank, ": mag_rv * mag_KE (eV) ", mag_rv**2 * (Emax-pot_energy)

   print rank, ": mid energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy()

   # propagate in time
   if have_quippy:
      quippy_propagate(at, dt=movement_args['MD_atom_timestep'], n_steps=movement_args['MD_atom_n_steps']) 
   else:
      exit_error("Need some non-quippy way of doing MD\n",3)

   if at.get_potential_energy()+at.get_kinetic_energy() > Emax+movement_args['MD_atom_energy_fuzz']:
      print rank, ": reject MD traj "
      at.set_positions(old_pos)

   print rank, ": final energy ", at.get_potential_energy(), at.get_kinetic_energy(), at.get_potential_energy()+ at.get_kinetic_energy()
   print rank, ": final positions ", at.get_positions()[0]
   print rank, ": final velo ", at.get_velocities()[0]

def do_MC_atom_walk(at, movement_args, Emax):
  if movement_args['MC_atom_n_steps'] <= 0: 
     return
  #DEBUG print "do_MC_atom_walk"
  n_steps = movement_args['MC_atom_n_steps']
  step_size = movement_args['MC_atom_step_size']
  acc_rate=0
  energy = eval_energy(at)
  for i_MC_step in range(n_steps):
    #DEBUG print "i_MC_step ",i_MC_step
    at_list=list(range(at.n))
    np.random.shuffle(at_list)
    for i_at in at_list:
      #DEBUG print "i_at ",i_at
      dx = np.random.normal(0.0, step_size)
      dy = np.random.normal(0.0, step_size)
      if movement_args['2D']:
	 dz=0.0
      else:
	 dz = np.random.normal(0.0, step_size)
      old_energy = energy
      old_pos = at.get_positions()
      new_pos = old_pos.copy()
      new_pos[i_at,:] += (dx, dy,dz)
      at.set_positions(new_pos)
      energy = eval_energy(at)
      if energy > Emax:
	at.set_positions(old_pos)
	energy = old_energy
      else:
	acc_rate += 1
  return float(acc_rate)/float(n_steps*at.n)

def walk_single_walker(at, movement_args, Emax):
  #DEBUG print "walk_single_walker"
  do_MC_atom_walk(at, movement_args, Emax)
  do_MD_atom_walk(at, movement_args, Emax)
  # do_MC_cell_step(at, movement_args, Emax)

def adjust_MC_step_size(at, MC_walk_routine, movement_args, step_size_str, Emax):
  print "adjust_MC_step_size ", MC_walk_routine, step_size_str
  for i_iter in range(200):
    at_test = at.copy()
    at_test.calc_connect()
    mean_acc_rate = MC_walk_routine(at_test, movement_args, Emax)
    print "  i_iter=%d mean_acc_rate=%f %s=%f" % (i_iter, mean_acc_rate, step_size_str, movement_args[step_size_str])
    if (mean_acc_rate < 0.2):
      movement_args[step_size_str] /= 1.2
    elif (mean_acc_rate > 0.8):
      movement_args[step_size_str] *= 1.2
    else:
      break

traj_io = quippy.CInOutput("traj.%d.xyz" % rank, action=quippy.OUTPUT)
if rank == 0:
   energy_io = open("energies", "w")

# WARNING: currently assumes that each node has equal number of walkers
def max_energy(walkers, n):
  # do local max
  energies_loc = np.array([ eval_energy(at) for at in walkers])
  energies = np.array(comm.allgather(energies_loc)).flatten()
  print rank , ": max_energies energies ",energies
  print rank , ": max_energies energies.argsort() ",energies.argsort()

  Emax_ind = energies.argsort()[-1:-n-1:-1]
  print rank, ": Emax_ind ", Emax_ind
  Emax = energies[Emax_ind]
  print rank, ": Emax ", Emax
  rank_of_max = np.floor(Emax_ind/len(walkers)).astype(int)
  print rank, ": rank_of_max ", rank_of_max

  return (Emax, np.mod(Emax_ind,len(walkers)), rank_of_max)


# do NS
def do_ns_loop():

   # WARNING not really random
   np.random.seed(rank)

   (Emax, Emax_ind, Emax_rank) = max_energy(walkers, 1)
   for at in walkers:
      walk_single_walker(at, movement_args, Emax+10)

   for i_ns_step in range(ns_args['n_steps']):
     print rank, ": starting ns loop ",i_ns_step
     # do atom MC step size adj
     ## if movement_args['MC_atom_n_steps'] > 0 and i_ns_step%10 == 0:
	## adjust_MC_step_size(walkers, do_MC_atom_walk, movement_args, 'MC_atom_step_size', Emax)

     print rank, ": LOOP START ", [ at.get_potential_energy() for at in walkers ]

     # do NS config dropping/forming
     (Emax, Emax_ind, Emax_rank) = max_energy(walkers, n_cull)

     print rank, ": got max ", Emax, Emax_ind, Emax_rank

     Emax_of_step=Emax[-1]
     if rank == 0:
        print "Emax_of_step ", Emax_of_step

     # record Emax walkers
     if rank == 0:
	for E in Emax:
	   energy_io.write("%d %f\n" % (i_ns_step, E))
     for (i, r) in zip(Emax_ind, Emax_rank):
         if rank == r: # my walker i
	    print rank, ": writing walker ",i
	    if have_quippy:
	       walkers[i].write(traj_io)
	    else:
	       exit_error("Need some non-quippy way of writing trajectory\n",3)

     # figure out where to send Emax configs
     if comm is not None:
	target_ind = np.floor(np.array(range(n_cull))/size).astype(int)
	if n_cull >= size:
	   target_rank = range(size) * int(n_cull/size)
	if n_cull % size != 0:
	   target_rank.append(range(n_cull) % size)
     else:
        target_rank = [0] * n_cull
	target_ind = range(n_cull)

     print rank, ": target_ind ", target_ind
     print rank, ": target_rank ", target_rank

     # move local Emaxes to beginning
     local_Emax_ind = []
     for (i, r) in zip (Emax_ind, Emax_rank):
        if r == rank:
	  local_Emax_ind.append(i)
     n_local_Emax = len(local_Emax_ind)
     Emax_pos = []
     Emax_cell = []
     for i in range(n_local_Emax):
        i_Emax = local_Emax_ind[i]
        Emax_pos.append(walkers[i_Emax].get_positions())
        Emax_cell.append(walkers[i_Emax].get_cell())
	walkers[i_Emax].set_positions(walkers[i].get_positions())
	walkers[i_Emax].set_cell(walkers[i].get_cell())
     for i in range(n_local_Emax):
        walkers[i].set_positions(Emax_pos[i])
        walkers[i].set_cell(Emax_cell[i])

     print rank, ": LOOP MID ", [ at.get_potential_energy() for at in walkers ]

     sendbuf=[ None ] * size
     for i in range(n_local_Emax):
         t_r = target_rank[local_Emax_ind[i]]
	 print rank, ": sending Emax ",i, " to rank ", t_r
	 if sendbuf[t_r] is None:
	    sendbuf[t_r] = []
	 sendbuf[t_r].append((walkers[i].get_positions(), walkers[i].get_cell()))

     Emax_remote = comm.alltoall(sendbuf)

     sendbuf=[None] * size
     for i in range(n_local_Emax):
        r = Emax_rank[local_Emax_ind[i]]
	print rank, ": sending config ",i," to rank ", r
	if sendbuf[r] is None:
	   sendbuf[r] = []
	sendbuf[r].append((walkers[i].get_positions(), walkers[i].get_cell()))

     config_remote = comm.alltoall(sendbuf)

     # copy remote Emax to local configs
     print rank, ": len(Emax_remote) ",len(Emax_remote)
     n_config_local = 0
     for data_from_rank in Emax_remote:
	print rank, ": len(data_from_rank) ",len(data_from_rank)
        for entry in data_from_rank:
	    if entry is not None:
	       print rank, ": received remote Emax, putting in ", n_config_local
	       walkers[n_config_local].set_positions(entry[0])
	       walkers[n_config_local].set_cell(entry[1])
	       n_config_local += 1

     # must be a better way of doing this
     local_Emax_ind = []
     for (i, r) in zip (Emax_ind, Emax_rank):
        if r == rank:
	  local_Emax_ind.append(i)
     print rank, ": local Emaxes count ", sum(Emax_rank == rank)
     print rank, ": local_Emax_ind ", local_Emax_ind
     # copy configs into proper places
     local_Emax_i = 0
     for data_from_rank in config_remote:
	for entry in data_from_rank:
	   print rank, ": received remote config, putting in ", local_Emax_ind[local_Emax_i]
	   walkers[local_Emax_ind[local_Emax_i]].set_positions(entry[0])
	   walkers[local_Emax_ind[local_Emax_i]].set_cell(entry[1])
	   local_Emax_i += 1

     print rank, ": LOOP END ", [ at.get_potential_energy() for at in walkers ]

     comm.Abort()

     # move cloned walkers
     for at in walkers:
	print rank, ": pre-move walkers", at.get_positions()[0]
     print rank, ": pre-move energies", [ eval_energy(at) for at in walkers ]

     if rank == clone_rank:
	walk_single_walker(walkers[clone_index-my_first_walker], movement_args, Emax)

     for at in walkers:
	print rank, ": post-move walkers", at.get_positions()[0]
     print rank, ": post-move energies", [ eval_energy(at) for at in walkers ]

do_ns_loop()

if rank == 0:
   energy_io.close()
traj_io.close()
MPI.Finalize()
sys.exit(0)
